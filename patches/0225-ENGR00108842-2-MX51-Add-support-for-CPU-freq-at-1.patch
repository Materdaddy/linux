From 217e1eddf2c9eae8fb65cbed24b2096f9d503bd8 Mon Sep 17 00:00:00 2001
From: Ranjani Vaidyanathan-RA5478 <Ranjani.Vaidyanathan@freescale.com>
Date: Tue, 19 May 2009 17:36:56 -0500
Subject: [PATCH] ENGR00108842-2 : MX51: Add support for CPU freq at 1GHz.

Added 1GHz CPU working point support.
Set the CPU working points based on the frequency the CPU is booted which
can be changed using the clock command in redboot.
Also fix the CPUFREQ driver so that the BogoMips are correct when CPU freq
is set to a different value in redboot.

Signed-off-by: Ranjani Vaidyanathan-RA5478 <Ranjani.Vaidyanathan@freescale.com>
---
 arch/arm/mach-mx51/clock.c        |   60 +++++++++++++++++++++++++++++++++++-
 arch/arm/mach-mx51/devices.c      |    2 +-
 arch/arm/mach-mx51/mx51_3stack.c  |   24 +++++++++++++--
 arch/arm/mach-mx51/mx51_babbage.c |   15 +++++++--
 4 files changed, 92 insertions(+), 9 deletions(-)

diff --git a/arch/arm/mach-mx51/clock.c b/arch/arm/mach-mx51/clock.c
index 9300a7e..ee77b30 100644
--- a/arch/arm/mach-mx51/clock.c
+++ b/arch/arm/mach-mx51/clock.c
@@ -13,6 +13,8 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/types.h>
+#include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
@@ -55,6 +57,7 @@ extern int cpufreq_trig_needed;
 static int cpu_clk_set_wp(int wp);
 extern void propagate_rate(struct clk *tclk);
 struct cpu_wp *(*get_cpu_wp)(int *wp);
+void (*set_num_cpu_wp)(int num);
 
 static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
 {
@@ -3040,7 +3043,8 @@ static void clk_tree_init(void)
 int __init mxc_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
 {
 	struct clk **clkp;
-	int i, reg;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
 
 	ckil_clk.rate = ckil;
 	osc_clk.rate = osc;
@@ -3126,8 +3130,60 @@ int __init mxc_clocks_init(unsigned long ckil, unsigned long osc, unsigned long
 	clk_set_parent(&gpu3d_clk, &ahb_clk);
 	clk_set_parent(&gpu2d_clk, &ahb_clk);
 
-	/* Set the current working point. */
 	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	if (pll1_main_clk.rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_main_clk.rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_main_clk.rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_main_clk.rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+
+	for (j = 0; j < cpu_wp_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_wp_tbl[j].cpu_podf =
+				(pll1_main_clk.rate / cpu_wp_tbl[j].cpu_rate)
+				- 1;
+			if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) >
+					cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_podf++;
+				cpu_wp_tbl[j].cpu_rate =
+					 pll1_main_clk.rate/
+					 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+				cpu_wp_tbl[j].cpu_rate *= 1000;
+			}
+			if (pll1_main_clk.rate/(cpu_wp_tbl[j].cpu_podf + 1) <
+						cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_rate = pll1_main_clk.rate;
+			}
+		}
+	cpu_wp_tbl[j].pll_rate = pll1_main_clk.rate;
+	}
+	/* Set the current working point. */
 	for (i = 0; i < cpu_wp_nr; i++) {
 		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
 			cpu_curr_wp = i;
diff --git a/arch/arm/mach-mx51/devices.c b/arch/arm/mach-mx51/devices.c
index 41466a2..9528244 100644
--- a/arch/arm/mach-mx51/devices.c
+++ b/arch/arm/mach-mx51/devices.c
@@ -793,7 +793,7 @@ struct mxc_dvfs_platform_data dvfs_core_data = {
 	.upcnt_val = 10,
 	.dncnt_val = 10,
 	.delay_time = 30,
-	.num_wp = 2,
+	.num_wp = 3,
 };
 
 /*! Device Definition for MXC DVFS core */
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index c9f0143..a133e02 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -62,10 +62,21 @@
  */
 extern void __init mx51_3stack_io_init(void);
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
 
-/* working point(wp): 0 - 800MHz; 1 - 200MHz; */
+/* working point(wp): 0 - 1GHz; 1 - 800MHz, 2 - 167MHz; */
 static struct cpu_wp cpu_wp_auto[] = {
 	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
 	 .pll_rate = 800000000,
 	 .cpu_rate = 800000000,
 	 .pdf = 0,
@@ -76,7 +87,7 @@ static struct cpu_wp cpu_wp_auto[] = {
 	 .cpu_voltage = 1050000,},
 	{
 	 .pll_rate = 800000000,
-	 .cpu_rate = 160000000,
+	 .cpu_rate = 167000000,
 	 .pdf = 4,
 	 .mfi = 8,
 	 .mfd = 2,
@@ -87,10 +98,16 @@ static struct cpu_wp cpu_wp_auto[] = {
 
 struct cpu_wp *mx51_3stack_get_cpu_wp(int *wp)
 {
-	*wp = 2;
+	*wp = num_cpu_wp;
 	return cpu_wp_auto;
 }
 
+void mx51_3stack_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
 static void mxc_nop_release(struct device *dev)
 {
 	/* Nothing */
@@ -1048,6 +1065,7 @@ static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
 	mxc_cpu_init();
 
 	get_cpu_wp = mx51_3stack_get_cpu_wp;
+	set_num_cpu_wp = mx51_3stack_set_num_cpu_wp;
 #ifdef CONFIG_DISCONTIGMEM
 	do {
 		int nid;
diff --git a/arch/arm/mach-mx51/mx51_babbage.c b/arch/arm/mach-mx51/mx51_babbage.c
index 720d6bf..5077e6a 100644
--- a/arch/arm/mach-mx51/mx51_babbage.c
+++ b/arch/arm/mach-mx51/mx51_babbage.c
@@ -61,9 +61,18 @@
 extern void __init mx51_babbage_io_init(void);
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
 
-/* working point(wp): 0 - 800MHz; 1 - 200MHz; */
+/* working point(wp): 0 - 1GHz; 1 - 800MHz, 2 - 167MHz; */
 static struct cpu_wp cpu_wp_auto[] = {
 	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
 	 .pll_rate = 800000000,
 	 .cpu_rate = 800000000,
 	 .pdf = 0,
@@ -74,7 +83,7 @@ static struct cpu_wp cpu_wp_auto[] = {
 	 .cpu_voltage = 1050000,},
 	{
 	 .pll_rate = 800000000,
-	 .cpu_rate = 160000000,
+	 .cpu_rate = 167000000,
 	 .pdf = 4,
 	 .mfi = 8,
 	 .mfd = 2,
@@ -85,7 +94,7 @@ static struct cpu_wp cpu_wp_auto[] = {
 
 struct cpu_wp *mx51_babbage_get_cpu_wp(int *wp)
 {
-	*wp = 2;
+	*wp = 3;
 	return cpu_wp_auto;
 }
 
-- 
1.5.4.4

