From bb857f4ef228a60fe9f5ec4047ff87a686b8b336 Mon Sep 17 00:00:00 2001
From: Katherine Lu <katherine.lu@freescale.com>
Date: Mon, 25 May 2009 16:48:36 +0800
Subject: [PATCH] ENGR00112654 MX35: Port bluetooth pcm driver to 2.6.28 kernel

1. port bluetooth pcm driver to 2.6.28 kernel
2. modify imx-ssi to support multi-ssi simultaneously

Signed-off-by: Katherine Lu <katherine.lu@freescale.com>
---
 arch/arm/configs/imx35_3stack_defconfig |    7 +-
 arch/arm/plat-mxc/include/mach/mxc.h    |    2 +
 sound/soc/codecs/Kconfig                |    3 +
 sound/soc/codecs/Makefile               |    2 +
 sound/soc/codecs/bluetooth.c            |  147 ++++++++++++++++++
 sound/soc/imx/Kconfig                   |    7 +
 sound/soc/imx/Makefile                  |    2 +
 sound/soc/imx/imx-3stack-ak4647.c       |    9 +-
 sound/soc/imx/imx-3stack-bt.c           |  256 +++++++++++++++++++++++++++++++
 sound/soc/imx/imx-3stack-bt.h           |   21 +++
 sound/soc/imx/imx-3stack-sgtl5000.c     |   12 +-
 sound/soc/imx/imx-3stack-wm8350.c       |   11 +-
 sound/soc/imx/imx-ssi.c                 |   76 +++++----
 sound/soc/imx/imx-ssi.h                 |    2 +-
 14 files changed, 510 insertions(+), 47 deletions(-)

diff --git a/arch/arm/configs/imx35_3stack_defconfig b/arch/arm/configs/imx35_3stack_defconfig
index c897e9e..61b3007 100644
--- a/arch/arm/configs/imx35_3stack_defconfig
+++ b/arch/arm/configs/imx35_3stack_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.28
-# Thu Apr 23 19:09:03 2009
+# Mon May 25 17:36:42 2009
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -163,6 +163,7 @@ CONFIG_ARCH_MXC=y
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
 # CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_STMP3XXX is not set
 
 #
 # Boot options
@@ -1152,10 +1153,12 @@ CONFIG_SND_MXC_SOC_IRAM=y
 CONFIG_SND_SOC_IMX_3STACK_SGTL5000=y
 CONFIG_SND_SOC_IMX_3STACK_AK4647=y
 CONFIG_SND_SOC_IMX_3STACK_WM8580=y
+CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH=y
 # CONFIG_SND_SOC_ALL_CODECS is not set
 CONFIG_SND_SOC_WM8580=y
 CONFIG_SND_SOC_SGTL5000=y
 CONFIG_SND_SOC_AK4647=y
+CONFIG_SND_SOC_BLUETOOTH=y
 # CONFIG_SOUND_PRIME is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
@@ -1438,6 +1441,7 @@ CONFIG_RTC_INTF_DEV=y
 #
 CONFIG_RTC_MXC=y
 # CONFIG_RTC_DRV_MXC_V2 is not set
+# CONFIG_RTC_DRV_IMXDI is not set
 CONFIG_RTC_MC13892=y
 # CONFIG_DMADEVICES is not set
 CONFIG_REGULATOR=y
@@ -1737,6 +1741,7 @@ CONFIG_CRYPTO=y
 # CONFIG_CRYPTO_CRYPTD is not set
 # CONFIG_CRYPTO_AUTHENC is not set
 # CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
 
 #
 # Authenticated Encryption with Associated Data
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 1f2ddca..9de5095 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -413,6 +413,8 @@ void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
 int tzic_enable_wake(int is_idle);
 void gpio_activate_audio_ports(void);
 void gpio_inactivate_audio_ports(void);
+void gpio_activate_bt_audio_port(void);
+void gpio_inactivate_bt_audio_port(void);
 
 #endif
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 45a1288..d692dbe 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -130,3 +130,6 @@ config SND_SOC_STMP378X_CODEC
 config SND_SOC_STMP3XXX_SPDIF
 	tristate
 	depends on SND_SOC
+
+config SND_SOC_BLUETOOTH
+        tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index b5e5b51..092bc87 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -24,6 +24,7 @@ snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-ak4647-objs := ak4647.o
 snd-soc-stmp378x-codec-objs := stmp378x_codec.o
 snd-soc-stmp3xxx-spdif-objs := stmp3xxx_spdif.o
+snd-soc-bluetooth-objs := bluetooth.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_AD1980)	+= snd-soc-ad1980.o
@@ -51,3 +52,4 @@ obj-$(CONFIG_SND_SOC_SGTL5000)	+= snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_AK4647)    += snd-soc-ak4647.o
 obj-$(CONFIG_SND_SOC_STMP378X_CODEC)	+= snd-soc-stmp378x-codec.o
 obj-$(CONFIG_SND_SOC_STMP3XXX_SPDIF)	+= snd-soc-stmp3xxx-spdif.o
+obj-$(CONFIG_SND_SOC_BLUETOOTH)    += snd-soc-bluetooth.o
diff --git a/sound/soc/codecs/bluetooth.c b/sound/soc/codecs/bluetooth.c
new file mode 100644
index 0000000..f77e951
--- /dev/null
+++ b/sound/soc/codecs/bluetooth.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bluetooth.c
+ * @brief Driver for bluetooth PCM interface
+ *
+ * @ingroup Sound
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#define BLUETOOTH_RATES SNDRV_PCM_RATE_8000
+
+#define BLUETOOTH_FORMATS SNDRV_PCM_FMTBIT_S16_LE
+
+struct snd_soc_dai bt_dai = {
+	.name = "bluetooth",
+	.playback = {
+		     .stream_name = "Playback",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = BLUETOOTH_RATES,
+		     .formats = BLUETOOTH_FORMATS,
+		     },
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = BLUETOOTH_RATES,
+		    .formats = BLUETOOTH_FORMATS,
+		    },
+};
+EXPORT_SYMBOL_GPL(bt_dai);
+
+static int bt_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec->name = "bluetooth";
+	codec->owner = THIS_MODULE;
+	codec->dai = &bt_dai;
+	codec->num_dai = 1;
+
+	snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		pr_err("failed to create bluetooth pcms\n");
+		return ret;
+	}
+
+	ret = snd_soc_register_card(socdev);
+	strcpy(codec->card->id, "bluetooth");
+
+	if (ret < 0) {
+		pr_err("bluetooth: failed to register card\n");
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+		return ret;
+	}
+	return 0;
+}
+
+static struct snd_soc_device *bt_socdev;
+
+static int bt_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret = 0;
+
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	bt_socdev = socdev;
+
+	ret = bt_init(socdev);
+	if (ret < 0) {
+		pr_err("Bluetooth codec initialisation failed\n");
+		kfree(codec);
+	}
+
+	return ret;
+}
+
+/* power down chip */
+static int bt_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+	kfree(codec);
+
+	return 0;
+}
+
+static int bt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int bt_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_bt = {
+	.probe = bt_probe,
+	.remove = bt_remove,
+	.suspend = bt_suspend,
+	.resume = bt_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_bt);
+
+MODULE_DESCRIPTION("ASoC bluetooth codec driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 0bf5f9b..d2726e3 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -53,5 +53,12 @@ config SND_SOC_IMX_3STACK_WM8580
    Say Y if you want to add support for Soc audio on IMX 3STACK
    with the WM8580
 
+config SND_SOC_IMX_3STACK_BLUETOOTH
+ tristate "SoC Audio support for IMX - BLUETOOTH"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_BLUETOOTH
+ help
+   Say Y if you want to add support for Soc audio on IMX 3STACK
+   with the BLUETOOTH
 endif
 
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index 44f93c5..a09b246 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -16,4 +16,6 @@ snd-soc-imx-3stack-ak4647-objs := imx-3stack-ak4647.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_AK4647) += snd-soc-imx-3stack-ak4647.o
 snd-soc-imx-3stack-wm8580-objs := imx-3stack-wm8580.o
 obj-$(CONFIG_SND_SOC_IMX_3STACK_WM8580) += snd-soc-imx-3stack-wm8580.o
+snd-soc-imx-3stack-bt-objs := imx-3stack-bt.o
+obj-$(CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH) += snd-soc-imx-3stack-bt.o
 
diff --git a/sound/soc/imx/imx-3stack-ak4647.c b/sound/soc/imx/imx-3stack-ak4647.c
index 4c03263..aaab351 100644
--- a/sound/soc/imx/imx-3stack-ak4647.c
+++ b/sound/soc/imx/imx-3stack-ak4647.c
@@ -319,10 +319,12 @@ static int imx_3stack_ak4647_init(struct snd_soc_codec *codec)
 	return 0;
 }
 
+static struct snd_soc_dai imx_3stack_cpu_dai;
+
 static struct snd_soc_dai_link imx_3stack_dai = {
 	.name = "ak4647",
 	.stream_name = "ak4647",
-	.cpu_dai = &imx_ssi_dai,
+	.cpu_dai = &imx_3stack_cpu_dai,
 	.codec_dai = &ak4647_hifi_dai,
 	.init = imx_3stack_ak4647_init,
 	.ops = &imx_3stack_hifi_ops,
@@ -354,10 +356,11 @@ static int __init imx_3stack_ak4647_probe(struct platform_device *pdev)
 	dev_data->init();
 
 	/* imx_3stack ak4647 hifi interface */
+	imx_ssi_dai_init(&imx_3stack_cpu_dai);
 	if (dev_data->src_port == 1)
-		imx_ssi_dai.name = "imx-ssi-1";
+		imx_3stack_cpu_dai.name = "imx-ssi-1";
 	else
-		imx_ssi_dai.name = "imx-ssi-3";
+		imx_3stack_cpu_dai.name = "imx-ssi-3";
 
 	/* Configure audio port 3 */
 	gpio_activate_audio_ports();
diff --git a/sound/soc/imx/imx-3stack-bt.c b/sound/soc/imx/imx-3stack-bt.c
new file mode 100644
index 0000000..365f17d
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-bt.c
@@ -0,0 +1,256 @@
+/*
+ * imx-3stack-bt.c  --  SoC bluetooth audio for imx_3stack
+ *
+ * Copyright 2008-2009 Freescale  Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <mach/mxc.h>
+
+#include "imx-pcm.h"
+#include "imx-ssi.h"
+#include "imx-3stack-bt.h"
+
+#define BT_SSI_MASTER	1
+
+struct imx_3stack_priv {
+	struct platform_device *pdev;
+	int active;
+};
+
+static struct imx_3stack_priv machine_priv;
+
+static void imx_3stack_init_dam(int ssi_port, int dai_port)
+{
+	/* bt uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+	unsigned int ssi_ptcr = 0;
+	unsigned int dai_ptcr = 0;
+	unsigned int ssi_pdcr = 0;
+	unsigned int dai_pdcr = 0;
+
+	/* reset port ssi_port & dai_port */
+	__raw_writel(0, DAM_PTCR(ssi_port));
+	__raw_writel(0, DAM_PTCR(dai_port));
+	__raw_writel(0, DAM_PDCR(ssi_port));
+	__raw_writel(0, DAM_PDCR(dai_port));
+
+	/* set to synchronous */
+	ssi_ptcr |= AUDMUX_PTCR_SYN;
+	dai_ptcr |= AUDMUX_PTCR_SYN;
+
+#if BT_SSI_MASTER
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TFSDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TFSDIR;
+	dai_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	dai_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+#endif
+
+	__raw_writel(ssi_ptcr, DAM_PTCR(ssi_port));
+	__raw_writel(dai_ptcr, DAM_PTCR(dai_port));
+	__raw_writel(ssi_pdcr, DAM_PDCR(ssi_port));
+	__raw_writel(dai_pdcr, DAM_PDCR(dai_port));
+}
+
+static int imx_3stack_bt_startup(struct snd_pcm_substream *substream)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+
+	if (!priv->active)
+		gpio_activate_bt_audio_port();
+	priv->active++;
+	return 0;
+}
+
+static int imx_3stack_bt_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *pcm_link = rtd->dai;
+	struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+	unsigned int channels = params_channels(params);
+	int ret = 0;
+	u32 dai_format;
+
+#if BT_SSI_MASTER
+	dai_format = SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_IB_IF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+#else
+	dai_format = SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_IB_IF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+#endif
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc, 2);
+
+	/* set the SSI system clock as input (unused) */
+	snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static void imx_3stack_bt_shutdown(struct snd_pcm_substream *substream)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+
+	priv->active--;
+	if (!priv->active)
+		gpio_inactivate_bt_audio_port();
+}
+
+/*
+ * imx_3stack bt DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_bt_ops = {
+	.startup = imx_3stack_bt_startup,
+	.hw_params = imx_3stack_bt_hw_params,
+	.shutdown = imx_3stack_bt_shutdown,
+};
+
+static struct snd_soc_dai imx_3stack_cpu_dai;
+
+static struct snd_soc_dai_link imx_3stack_dai = {
+	.name = "bluetooth",
+	.stream_name = "bluetooth",
+	.cpu_dai = &imx_3stack_cpu_dai,
+	.codec_dai = &bt_dai,
+	.ops = &imx_3stack_bt_ops,
+};
+
+static struct snd_soc_machine snd_soc_machine_imx_3stack = {
+	.name = "imx-3stack",
+	.dai_link = &imx_3stack_dai,
+	.num_links = 1,
+};
+
+static struct snd_soc_device imx_3stack_snd_devdata = {
+	.machine = &snd_soc_machine_imx_3stack,
+	.platform = &imx_soc_platform,
+	.codec_dev = &soc_codec_dev_bt,
+};
+
+/*
+ * This function will register the snd_soc_pcm_link drivers.
+ * It also registers devices for platform DMA, I2S, SSP and registers an
+ * I2C driver to probe the codec.
+ */
+static int __init imx_3stack_bt_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *dev_data = pdev->dev.platform_data;
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct snd_soc_dai *cpu_dai;
+
+	/* imx_3stack bt interface */
+	imx_ssi_dai_init(&imx_3stack_cpu_dai);
+	imx_3stack_cpu_dai.private_data = dev_data;
+
+	if (dev_data->src_port == 1)
+		imx_3stack_cpu_dai.name = "imx-ssi-1";
+	else
+		imx_3stack_cpu_dai.name = "imx-ssi-3";
+
+	/* Configure audio port */
+	imx_3stack_init_dam(dev_data->src_port, dev_data->ext_port);
+
+	priv->pdev = pdev;
+	priv->active = 0;
+	return 0;
+
+}
+
+static int __devexit imx_3stack_bt_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver imx_3stack_bt_driver = {
+	.probe = imx_3stack_bt_probe,
+	.remove = __devexit_p(imx_3stack_bt_remove),
+	.driver = {
+		   .name = "imx-3stack-bt",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static struct platform_device *imx_3stack_snd_device;
+
+static int __init imx_3stack_asoc_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_3stack_bt_driver);
+	if (ret < 0)
+		goto exit;
+	imx_3stack_snd_device = platform_device_alloc("soc-audio", 4);
+	if (!imx_3stack_snd_device)
+		goto err_device_alloc;
+	platform_set_drvdata(imx_3stack_snd_device, &imx_3stack_snd_devdata);
+	imx_3stack_snd_devdata.dev = &imx_3stack_snd_device->dev;
+	ret = platform_device_add(imx_3stack_snd_device);
+	if (0 == ret)
+		goto exit;
+
+	platform_device_put(imx_3stack_snd_device);
+err_device_alloc:
+	platform_driver_unregister(&imx_3stack_bt_driver);
+exit:
+	return ret;
+}
+
+static void __exit imx_3stack_asoc_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_bt_driver);
+	platform_device_unregister(imx_3stack_snd_device);
+}
+
+module_init(imx_3stack_asoc_init);
+module_exit(imx_3stack_asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC bluetooth imx_3stack");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-3stack-bt.h b/sound/soc/imx/imx-3stack-bt.h
new file mode 100644
index 0000000..4e1d354
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-bt.h
@@ -0,0 +1,21 @@
+/*
+ * imx-3stack-bt.h  --  Bluetooth PCM driver header file for Freescale IMX
+ *
+ * Copyright 2008-2009 Freescale  Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_BTPCM_H
+#define _MXC_BTPCM_H
+
+extern struct snd_soc_dai bt_dai;
+extern struct snd_soc_codec_device soc_codec_dev_bt;
+#endif
diff --git a/sound/soc/imx/imx-3stack-sgtl5000.c b/sound/soc/imx/imx-3stack-sgtl5000.c
index f927175..0d22b30 100644
--- a/sound/soc/imx/imx-3stack-sgtl5000.c
+++ b/sound/soc/imx/imx-3stack-sgtl5000.c
@@ -366,11 +366,13 @@ static int imx_3stack_sgtl5000_init(struct snd_soc_codec *codec)
 	return 0;
 }
 
+static struct snd_soc_dai imx_3stack_cpu_dai;
+
 /* imx_3stack digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link imx_3stack_dai = {
 	.name = "SGTL5000",
 	.stream_name = "SGTL5000",
-	.cpu_dai = &imx_ssi_dai,
+	.cpu_dai = &imx_3stack_cpu_dai,
 	.codec_dai = &sgtl5000_dai,
 	.init = imx_3stack_sgtl5000_init,
 	.ops = &imx_3stack_ops,
@@ -425,7 +427,9 @@ static int __devinit imx_3stack_sgtl5000_probe(struct platform_device *pdev)
 
 	priv->sysclk = plat->sysclk;
 	priv->pdev = pdev;
-	imx_ssi_dai.private_data = plat;
+
+	imx_ssi_dai_init(&imx_3stack_cpu_dai);
+	imx_3stack_cpu_dai.private_data = plat;
 
 	codec_data = kzalloc(sizeof(struct sgtl5000_platform_data), GFP_KERNEL);
 	if (!codec_data) {
@@ -441,9 +445,9 @@ static int __devinit imx_3stack_sgtl5000_probe(struct platform_device *pdev)
 	imx_3stack_init_dam(plat->src_port, plat->ext_port);
 
 	if (plat->src_port == 2)
-		imx_ssi_dai.name = "imx-ssi-3";
+		imx_3stack_cpu_dai.name = "imx-ssi-3";
 	else
-		imx_ssi_dai.name = "imx-ssi-1";
+		imx_3stack_cpu_dai.name = "imx-ssi-1";
 
 	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
 	if (ret < 0) {
diff --git a/sound/soc/imx/imx-3stack-wm8350.c b/sound/soc/imx/imx-3stack-wm8350.c
index b7895df..15aa186 100644
--- a/sound/soc/imx/imx-3stack-wm8350.c
+++ b/sound/soc/imx/imx-3stack-wm8350.c
@@ -576,11 +576,12 @@ static int imx_3stack_wm8350_init(struct snd_soc_codec *codec)
 
 }
 
+static struct snd_soc_dai imx_3stack_cpu_dai;
 /* imx_3stack digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link imx_3stack_dai = {
 	.name = "WM8350",
 	.stream_name = "WM8350",
-	.cpu_dai = &imx_ssi_dai,
+	.cpu_dai = &imx_3stack_cpu_dai,
 	.codec_dai = &wm8350_dai,
 	.init = imx_3stack_wm8350_init,
 	.ops = &imx_3stack_ops,
@@ -622,7 +623,9 @@ static int __devinit imx_3stack_wm8350_probe(struct platform_device *pdev)
 
 	priv->pdev = pdev;
 	priv->wm8350 = wm8350;
-	imx_ssi_dai.private_data = plat;
+
+	imx_ssi_dai_init(&imx_3stack_cpu_dai);
+	imx_3stack_cpu_dai.private_data = plat;
 
 	imx_3stack_wm8350_setup.regulator1 = plat->regulator1;
 	imx_3stack_wm8350_setup.regulator2 = plat->regulator2;
@@ -631,9 +634,9 @@ static int __devinit imx_3stack_wm8350_probe(struct platform_device *pdev)
 	imx_3stack_init_dam(plat->src_port, plat->ext_port);
 
 	if (plat->src_port == 2)
-		strcpy(imx_ssi_dai.name, "imx-ssi-3");
+		strcpy(imx_3stack_cpu_dai.name, "imx-ssi-3");
 	else
-		strcpy(imx_ssi_dai.name, "imx-ssi-1");
+		strcpy(imx_3stack_cpu_dai.name, "imx-ssi-1");
 
 	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
 	if (ret < 0) {
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
index 829374b..ddf0661 100644
--- a/sound/soc/imx/imx-ssi.c
+++ b/sound/soc/imx/imx-ssi.c
@@ -736,41 +736,49 @@ static void imx_ssi_remove(struct platform_device *pdev,
 	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
 	SNDRV_PCM_FMTBIT_S24_LE)
 
-struct snd_soc_dai imx_ssi_dai = {
-	.name = "imx-ssi",
-	.id = 0,
-	.type = SND_SOC_DAI_PCM,
-	.probe = imx_ssi_probe,
-	.suspend = imx_ssi_suspend,
-	.remove = imx_ssi_remove,
-	.resume = imx_ssi_resume,
-	.playback = {
-		     .channels_min = 1,
-		     .channels_max = 2,
-		     .rates = IMX_SSI_RATES,
-		     .formats = IMX_SSI_FORMATS,
-		     },
-	.capture = {
-		    .channels_min = 1,
-		    .channels_max = 2,
-		    .rates = IMX_SSI_RATES,
-		    .formats = IMX_SSI_FORMATS,
-		    },
-	.ops = {
-		.startup = imx_ssi_startup,
-		.shutdown = imx_ssi_shutdown,
-		.trigger = imx_ssi_trigger,
-		.prepare = imx_ssi_prepare,
-		.hw_params = imx_ssi_hw_params,
-		},
-	.dai_ops = {
-		    .set_sysclk = imx_ssi_set_dai_sysclk,
-		    .set_clkdiv = imx_ssi_set_dai_clkdiv,
-		    .set_fmt = imx_ssi_set_dai_fmt,
-		    .set_tdm_slot = imx_ssi_set_dai_tdm_slot,
-		    },
+static struct snd_soc_pcm_stream imx_ssi_playback = {
+	.channels_min = 1,
+	.channels_max = 2,
+	.rates = IMX_SSI_RATES,
+	.formats = IMX_SSI_FORMATS,
 };
-EXPORT_SYMBOL_GPL(imx_ssi_dai);
+
+static struct snd_soc_pcm_stream imx_ssi_capture = {
+	.channels_min = 1,
+	.channels_max = 2,
+	.rates = IMX_SSI_RATES,
+	.formats = IMX_SSI_FORMATS,
+};
+
+static struct snd_soc_ops imx_ssi_ops = {
+	.startup = imx_ssi_startup,
+	.shutdown = imx_ssi_shutdown,
+	.trigger = imx_ssi_trigger,
+	.prepare = imx_ssi_prepare,
+	.hw_params = imx_ssi_hw_params,
+};
+
+static struct snd_soc_dai_ops imx_ssi_dai_ops = {
+	.set_sysclk = imx_ssi_set_dai_sysclk,
+	.set_clkdiv = imx_ssi_set_dai_clkdiv,
+	.set_fmt = imx_ssi_set_dai_fmt,
+	.set_tdm_slot = imx_ssi_set_dai_tdm_slot,
+};
+
+void imx_ssi_dai_init(struct snd_soc_dai *imx_ssi_dai)
+{
+	imx_ssi_dai->id = 0;
+	imx_ssi_dai->type = SND_SOC_DAI_PCM;
+	imx_ssi_dai->probe = imx_ssi_probe;
+	imx_ssi_dai->suspend = imx_ssi_suspend;
+	imx_ssi_dai->remove = imx_ssi_remove;
+	imx_ssi_dai->resume = imx_ssi_resume;
+	imx_ssi_dai->playback = imx_ssi_playback;
+	imx_ssi_dai->capture = imx_ssi_capture;
+	imx_ssi_dai->ops = imx_ssi_ops;
+	imx_ssi_dai->dai_ops = imx_ssi_dai_ops;
+};
+EXPORT_SYMBOL_GPL(imx_ssi_dai_init);
 
 MODULE_AUTHOR
     ("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
diff --git a/sound/soc/imx/imx-ssi.h b/sound/soc/imx/imx-ssi.h
index ffb27e9..593eb6f 100644
--- a/sound/soc/imx/imx-ssi.h
+++ b/sound/soc/imx/imx-ssi.h
@@ -213,6 +213,6 @@
 #define IMX_SSI_DIV_2_OFF		(~SSI_STCCR_DIV2)
 #define IMX_SSI_DIV_2_ON		SSI_STCCR_DIV2
 
-extern struct snd_soc_dai imx_ssi_dai;
+extern void imx_ssi_dai_init(struct snd_soc_dai *imx_ssi_dai);
 
 #endif
-- 
1.5.4.4

