From a31e6299607e90bcd5c5c111722d4717d314cf4b Mon Sep 17 00:00:00 2001
From: Zhou Jingyu <b02241@freescale.com>
Date: Tue, 19 May 2009 14:10:17 +0800
Subject: [PATCH] ENGR00112563 add STMP3780 regulator driver

add STMP3780 regulator driver

Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
---
 arch/arm/configs/imx233_defconfig               |    7 +-
 arch/arm/mach-stmp3xxx/cpufreq.c                |    1 -
 arch/arm/mach-stmp3xxx/include/mach/power.h     |    4 +-
 arch/arm/mach-stmp3xxx/include/mach/regulator.h |    6 +
 arch/arm/mach-stmp3xxx/power.c                  |  258 +++++++++++---------
 arch/arm/mach-stmp3xxx/stmp378x_devb.c          |   11 -
 drivers/regulator/stmp3xxx.c                    |  300 +++++++++++++++++++++++
 7 files changed, 458 insertions(+), 129 deletions(-)

diff --git a/arch/arm/configs/imx233_defconfig b/arch/arm/configs/imx233_defconfig
index 0704f2c..3a7d5b7 100644
--- a/arch/arm/configs/imx233_defconfig
+++ b/arch/arm/configs/imx233_defconfig
@@ -1147,7 +1147,12 @@ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
 #
 CONFIG_RTC_DRV_STMP3XXX=y
 # CONFIG_DMADEVICES is not set
-# CONFIG_REGULATOR is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_STMP3XXX=y
 # CONFIG_UIO is not set
 
 #
diff --git a/arch/arm/mach-stmp3xxx/cpufreq.c b/arch/arm/mach-stmp3xxx/cpufreq.c
index 860807d..8002580 100644
--- a/arch/arm/mach-stmp3xxx/cpufreq.c
+++ b/arch/arm/mach-stmp3xxx/cpufreq.c
@@ -368,7 +368,6 @@ static int __init stmp3xxx_cpu_init(struct cpufreq_policy *policy)
 	policy->cpuinfo.max_freq = profiles[ARRAY_SIZE(profiles) - 1].cpu;
 	policy->cpuinfo.transition_latency = 1000000; /* 1 ms, assumed */
 	clk_put(cpu_clk);
-//	stmp3xxx_platform_add_regulator("cpufreq", 1);
 
 	return 0;
 }
diff --git a/arch/arm/mach-stmp3xxx/include/mach/power.h b/arch/arm/mach-stmp3xxx/include/mach/power.h
index 3ef58c1..ac90f86 100644
--- a/arch/arm/mach-stmp3xxx/include/mach/power.h
+++ b/arch/arm/mach-stmp3xxx/include/mach/power.h
@@ -60,6 +60,8 @@ struct stmp3xxx_platform_regulator_data {
 	struct regulation_constraints *constraints;
 };
 
-int stmp3xxx_platform_add_regulator(const char *name, int count);
+int stmp3xxx_register_regulator(
+		struct stmp3xxx_regulator *reg_data, int reg,
+		      struct regulator_init_data *initdata);
 
 #endif /* __VOLTAGE_H */
diff --git a/arch/arm/mach-stmp3xxx/include/mach/regulator.h b/arch/arm/mach-stmp3xxx/include/mach/regulator.h
index c2a8e0f..01880bd 100644
--- a/arch/arm/mach-stmp3xxx/include/mach/regulator.h
+++ b/arch/arm/mach-stmp3xxx/include/mach/regulator.h
@@ -14,4 +14,10 @@
 #define __PLAT_REGULATOR_H_
 #define STMP3XXX_REG5V_NOT_USB 0
 #define STMP3XXX_REG5V_IS_USB 1
+#define STMP3XXX_VDDD 0
+#define STMP3XXX_VDDA 1
+#define STMP3XXX_VDDIO 2
+#define STMP3XXX_VDDDBO 3
+#define STMP3XXX_OVERALL_CUR 4
+
 #endif
diff --git a/arch/arm/mach-stmp3xxx/power.c b/arch/arm/mach-stmp3xxx/power.c
index 238b273..7a49574 100644
--- a/arch/arm/mach-stmp3xxx/power.c
+++ b/arch/arm/mach-stmp3xxx/power.c
@@ -23,7 +23,9 @@
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/machine.h>
 #include <mach/power.h>
+#include <mach/regulator.h>
 #include <mach/regs-power.h>
+#include <mach/stmp3xxx.h>
 
 static int get_voltage(struct stmp3xxx_regulator *sreg)
 {
@@ -177,17 +179,6 @@ static int get_mode(struct stmp3xxx_regulator *sreg)
 	return val ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;
 }
 
-static struct regulation_constraints vddd_constraints = {
-	.name			= "vddd",
-	.min_uV			= 800000,
-	.max_uV			= 1575000,
-	.valid_modes_mask	= REGULATOR_MODE_FAST |
-				  REGULATOR_MODE_NORMAL,
-	.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
-				  REGULATOR_CHANGE_MODE,
-	.input_uV		= 5000000,
-};
-
 static struct stmp3xxx_platform_regulator_data vddd_data = {
 	.name		= "vddd",
 	.set_voltage	= set_voltage,
@@ -200,7 +191,6 @@ static struct stmp3xxx_platform_regulator_data vddd_data = {
 	.control_reg	= HW_POWER_VDDDCTRL_ADDR,
 	.min_voltage	= 800000,
 	.max_voltage	= 1575000,
-	.constraints	= &vddd_constraints,
 };
 
 static struct stmp3xxx_platform_regulator_data vdddbo_data = {
@@ -215,34 +205,6 @@ static struct stmp3xxx_platform_regulator_data vdddbo_data = {
 	.get_mode	= get_mode,
 	.min_voltage	= 800000,
 	.max_voltage	= 1575000,
-	.constraints	= &vddd_constraints,
-};
-
-static struct platform_device vddd_reg = {
-	.name		= "stmp3xxx_reg",
-	.id		= 1,
-	.dev		= {
-		.platform_data	= &vddd_data,
-	},
-};
-
-static struct platform_device vdddbo_reg = {
-	.name		= "stmp3xxx_reg",
-	.id		= 4,
-	.dev		= {
-		.platform_data	= &vdddbo_data,
-	},
-};
-
-static struct regulation_constraints vdda_constraints = {
-	.name			= "vdda",
-	.min_uV			= 1500000,
-	.max_uV			= 2275000,
-	.valid_modes_mask	= REGULATOR_MODE_FAST |
-				  REGULATOR_MODE_NORMAL,
-	.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
-				  REGULATOR_CHANGE_MODE,
-	.input_uV		= 5000000,
 };
 
 static struct stmp3xxx_platform_regulator_data vdda_data = {
@@ -257,26 +219,6 @@ static struct stmp3xxx_platform_regulator_data vdda_data = {
 	.control_reg	= HW_POWER_VDDACTRL_ADDR,
 	.min_voltage	= 1500000,
 	.max_voltage	= 2275000,
-	.constraints	= &vdda_constraints,
-};
-
-static struct platform_device vdda_reg = {
-	.name		= "stmp3xxx_reg",
-	.id 		= 2,
-	.dev 		= {
-		.platform_data	= &vdda_data,
-	},
-};
-
-static struct regulation_constraints vddio_constraints = {
-	.name			= "vddio",
-	.min_uV			= 2800000,
-	.max_uV			= 3575000,
-	.valid_modes_mask	= REGULATOR_MODE_FAST |
-				  REGULATOR_MODE_NORMAL,
-	.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
-				  REGULATOR_CHANGE_MODE,
-	.input_uV		= 5000000,
 };
 
 static struct stmp3xxx_platform_regulator_data vddio_data = {
@@ -291,15 +233,60 @@ static struct stmp3xxx_platform_regulator_data vddio_data = {
 	.control_reg	= HW_POWER_VDDIOCTRL_ADDR,
 	.min_voltage	= 2800000,
 	.max_voltage	= 3575000,
-	.constraints	= &vddio_constraints,
 };
 
-static struct platform_device vddio_reg = {
-	.name		= "stmp3xxx_reg",
-	.id		= 3,
-	.dev		= {
-		.platform_data	= &vddio_data,
-	},
+static struct regulator_init_data vddd_init = {
+	.constraints = {
+		.name			= "vddd",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+	}
+};
+
+static struct regulator_init_data vdddbo_init = {
+	.constraints = {
+		.name			= "vdddbo",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+	}
+};
+
+
+static struct regulator_init_data vdda_init = {
+	.constraints = {
+		.name			= "vdda",
+		.min_uV			= 1500000,
+		.max_uV			= 2275000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+	}
+};
+
+
+static struct regulator_init_data vddio_init = {
+	.constraints = {
+		.name			= "vddio",
+		.min_uV			= 2800000,
+		.max_uV			= 3575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+	}
 };
 
 /* now the current regulators */
@@ -399,16 +386,6 @@ static int cur_reg_get_mode(struct stmp3xxx_regulator *sreg)
 	return sreg->mode;
 }
 
-static struct regulation_constraints current_constraints = {
-	.name			= "current_constraints",
-	.valid_modes_mask	= REGULATOR_MODE_NORMAL |
-				  REGULATOR_MODE_FAST,
-	.valid_ops_mask		= REGULATOR_CHANGE_CURRENT |
-				  REGULATOR_CHANGE_MODE,
-	.max_uA                 = 0x7fffffff,
-	.min_uA                 = 0x0,
-};
-
 static struct stmp3xxx_platform_regulator_data overall_cur_data = {
 	.name		= "overall_current",
 	.set_current	= cur_reg_set_current,
@@ -419,15 +396,18 @@ static struct stmp3xxx_platform_regulator_data overall_cur_data = {
 	.set_mode	= cur_reg_set_mode,
 	.get_mode	= cur_reg_get_mode,
 	.max_current	= 0x7fffffff,
-	.constraints	= &current_constraints,
 };
 
-static struct platform_device overall_cur_reg = {
-	.name		= "stmp3xxx_reg",
-	.id		= 100,
-	.dev		= {
-		.platform_data	= &overall_cur_data,
-	},
+static struct regulator_init_data overall_cur_init = {
+	.constraints = {
+		.name			= "overall_current",
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL |
+					  REGULATOR_MODE_FAST,
+		.valid_ops_mask		= REGULATOR_CHANGE_CURRENT |
+					  REGULATOR_CHANGE_MODE,
+		.max_uA                 = 0x7fffffff,
+		.min_uA                 = 0x0,
+	}
 };
 
 static struct stmp3xxx_platform_regulator_data sibling_cur_data = {
@@ -439,11 +419,27 @@ static struct stmp3xxx_platform_regulator_data sibling_cur_data = {
 	.is_enabled	= cur_reg_is_enabled,
 	.set_mode	= cur_reg_set_mode,
 	.get_mode	= cur_reg_get_mode,
-	.constraints	= &current_constraints,
 };
 
-#if 0
-static struct platform_device *sibling_current_devices[100];
+static struct platform_device *devices[] = {
+	&stmp3xxx_keyboard,
+	&stmp3xxx_touchscreen,
+	&stmp3xxx_appuart,
+	&stmp3xxx_dbguart,
+	&stmp3xxx_watchdog,
+	&stmp3xxx_rtc,
+	&stmp3xxx_framebuffer,
+	&stmp3xxx_backlight,
+	&stmp3xxx_rotdec,
+	&stmp378x_i2c,
+	&stmp3xxx_persistent,
+	&stmp3xxx_dcp_bootstream,
+	&stmp3xxx_dcp,
+	&stmp3xxx_mtest,
+	&stmp3xxx_battery,
+	&stmp3xxx_pxp,
+};
+
 static int sibling_current_devices_num;
 
 int stmp3xxx_platform_add_regulator(const char *name, int count)
@@ -453,50 +449,82 @@ int stmp3xxx_platform_add_regulator(const char *name, int count)
 	for (i = sibling_current_devices_num;
 	     i < sibling_current_devices_num + count;
 	     i++) {
-		struct platform_device *p =
-			kzalloc(sizeof(struct platform_device), GFP_KERNEL);
+		struct regulator_init_data *sibling_init =
+			kzalloc(sizeof(struct regulator_init_data),
+			GFP_KERNEL);
+		struct stmp3xxx_regulator *curr_reg =
+			kzalloc(sizeof(struct stmp3xxx_regulator),
+			GFP_KERNEL);
 		struct stmp3xxx_platform_regulator_data *d =
 			kzalloc(sizeof(struct stmp3xxx_platform_regulator_data),
-				GFP_KERNEL);
-		if (!d || !p) {
-			int j;
-			for (j = i-1; j >= sibling_current_devices_num; j--) {
-				struct platform_device *q =
-					sibling_current_devices[j];
-				kfree(q->dev.platform_data);
-				kfree(q);
-			}
+			GFP_KERNEL);
+		if (!d || !curr_reg || !sibling_init)
 			return -ENOMEM;
-		}
-		p->name = kstrdup("stmp3xxx_reg", GFP_KERNEL);
-		p->id = 101 + i;
+
+		sibling_init->constraints.valid_modes_mask =
+			REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST;
+		sibling_init->constraints.valid_ops_mask =
+			REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_MODE;
+		sibling_init->constraints.max_uA = 0x7fffffff;
+		sibling_init->constraints.min_uA = 0x0;
+
 		memcpy(d, &sibling_cur_data, sizeof(sibling_cur_data));
 		d->parent_name = kstrdup(sibling_cur_data.parent_name,
 					 GFP_KERNEL);
 		snprintf(d->name, 80, "%s-%d",
 			 name, i - sibling_current_devices_num + 1);
-		p->dev.platform_data = d;
-		sibling_current_devices[i] = p;
+		sibling_init->constraints.name = kstrdup(d->name, GFP_KERNEL);
+		curr_reg->rdata = d;
+		stmp3xxx_register_regulator(curr_reg, 101 + i, sibling_init);
 	}
 	sibling_current_devices_num += count;
 	return 0;
 }
-#endif
-static struct platform_device *voltage_devices[] = {
-	&vddd_reg,
-	&vdda_reg,
-	&vddio_reg,
-	&vdddbo_reg,
+
+static struct stmp3xxx_regulator vddd_reg = {
+		.rdata = &vddd_data,
 };
 
+static struct stmp3xxx_regulator vdda_reg = {
+		.rdata = &vdda_data,
+};
+
+static struct stmp3xxx_regulator vddio_reg = {
+		.rdata = &vddio_data,
+};
+
+static struct stmp3xxx_regulator vdddbo_reg = {
+		.rdata = &vdddbo_data,
+};
+
+static struct stmp3xxx_regulator overall_cur_reg = {
+		.rdata = &overall_cur_data,
+};
+
+
 static int __init regulators_init(void)
 {
+	int i;
+	int retval = 0;
+	pr_debug("regulators_init \n");
 	HW_POWER_VDDIOCTRL_WR(0x00022614);
-	platform_add_devices(voltage_devices,
-			     ARRAY_SIZE(voltage_devices));
-	platform_device_register(&overall_cur_reg);
+	vdddbo_reg.parent = &vddd_reg;
+	stmp3xxx_register_regulator(&vddd_reg, STMP3XXX_VDDD, &vddd_init);
+	stmp3xxx_register_regulator(&vdddbo_reg, STMP3XXX_VDDDBO, &vdddbo_init);
+	stmp3xxx_register_regulator(&vdda_reg, STMP3XXX_VDDA, &vdda_init);
+	stmp3xxx_register_regulator(&vddio_reg, STMP3XXX_VDDIO, &vddio_init);
+	stmp3xxx_register_regulator(&overall_cur_reg,
+		STMP3XXX_OVERALL_CUR, &overall_cur_init);
+
+	for (i = 0; i < ARRAY_SIZE(devices); i++) {
+		retval = stmp3xxx_platform_add_regulator(devices[i]->name, 1);
+		if (retval)
+			return retval;
+	}
+	stmp3xxx_platform_add_regulator("mmc_ssp", 2);
+	stmp3xxx_platform_add_regulator("charger", 1);
+	stmp3xxx_platform_add_regulator("power-test", 1);
+	stmp3xxx_platform_add_regulator("cpufreq", 1);
 	return 0;
-//	return platform_add_devices(sibling_current_devices,
-//				    sibling_current_devices_num);
 }
-subsys_initcall(regulators_init);
+postcore_initcall(regulators_init);
diff --git a/arch/arm/mach-stmp3xxx/stmp378x_devb.c b/arch/arm/mach-stmp3xxx/stmp378x_devb.c
index 3ceb329..8e8007c 100644
--- a/arch/arm/mach-stmp3xxx/stmp378x_devb.c
+++ b/arch/arm/mach-stmp3xxx/stmp378x_devb.c
@@ -361,8 +361,6 @@ static struct i2c_board_info __initdata stmp3xxx_i2c_devices[] = {
 static void __init stmp378x_devb_init(void)
 {
 	struct fsl_usb2_platform_data *udata;
-	int i;
-
 	stmp3xxx_init();
 
 	i2c_register_board_info(0, stmp3xxx_i2c_devices, ARRAY_SIZE(stmp3xxx_i2c_devices));
@@ -378,15 +376,6 @@ static void __init stmp378x_devb_init(void)
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 	if (pwm_leds_enable)
 		platform_device_register(&stmp378x_leds);
-#if 0
-	for (i = 0; i < ARRAY_SIZE(devices); i++) {
-		struct platform_device *p = devices[i];
-		stmp3xxx_platform_add_regulator(p->name, 1);
-	}
-	stmp3xxx_platform_add_regulator("mmc_ssp", 2);
-	stmp3xxx_platform_add_regulator("charger", 1);
-	stmp3xxx_platform_add_regulator("power-test", 1);
-#endif
 }
 
 MACHINE_START(STMP378X, "STMP378X")
diff --git a/drivers/regulator/stmp3xxx.c b/drivers/regulator/stmp3xxx.c
new file mode 100644
index 0000000..762a184
--- /dev/null
+++ b/drivers/regulator/stmp3xxx.c
@@ -0,0 +1,300 @@
+/*
+ * Freescale STMP378X voltage regulators
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <mach/power.h>
+#include <mach/regulator.h>
+
+static int stmp3xxx_set_voltage(struct regulator_dev *reg, int MiniV, int uv)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	if (stmp_reg->rdata->set_voltage)
+		return stmp_reg->rdata->set_voltage(stmp_reg, uv);
+	else
+		return -ENOTSUPP;
+}
+
+
+static int stmp3xxx_get_voltage(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	if (stmp_reg->rdata->get_voltage)
+		return stmp_reg->rdata->get_voltage(stmp_reg);
+	else
+		return -ENOTSUPP;
+}
+
+static int stmp3xxx_set_current(struct regulator_dev *reg, int min_uA, int uA)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	if (stmp_reg->rdata->set_current)
+		return stmp_reg->rdata->set_current(stmp_reg, uA);
+	else
+		return -ENOTSUPP;
+}
+
+static int stmp3xxx_get_current(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	if (stmp_reg->rdata->get_current)
+		return stmp_reg->rdata->get_current(stmp_reg);
+	else
+		return -ENOTSUPP;
+}
+
+static int stmp3xxx_enable(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	return stmp_reg->rdata->enable(stmp_reg);
+}
+
+static int stmp3xxx_disable(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	return stmp_reg->rdata->disable(stmp_reg);
+}
+
+static int stmp3xxx_is_enabled(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	return stmp_reg->rdata->is_enabled(stmp_reg);
+}
+
+static int stmp3xxx_set_mode(struct regulator_dev *reg, unsigned int mode)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	return stmp_reg->rdata->set_mode(stmp_reg, mode);
+}
+
+static unsigned int stmp3xxx_get_mode(struct regulator_dev *reg)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	return stmp_reg->rdata->get_mode(stmp_reg);
+}
+
+static unsigned int stmp3xxx_get_optimum_mode(struct regulator_dev *reg,
+				int input_uV, int output_uV, int load_uA)
+{
+	struct stmp3xxx_regulator *stmp_reg = rdev_get_drvdata(reg);
+
+	if (stmp_reg->rdata->get_optimum_mode)
+		return stmp_reg->rdata->get_optimum_mode(stmp_reg, input_uV,
+							 output_uV, load_uA);
+	else
+		return -ENOTSUPP;
+}
+
+static struct regulator_ops stmp3xxx_rops = {
+	.set_voltage	= stmp3xxx_set_voltage,
+	.get_voltage	= stmp3xxx_get_voltage,
+	.set_current_limit	= stmp3xxx_set_current,
+	.get_current_limit	= stmp3xxx_get_current,
+	.enable		= stmp3xxx_enable,
+	.disable	= stmp3xxx_disable,
+	.is_enabled	= stmp3xxx_is_enabled,
+	.set_mode	= stmp3xxx_set_mode,
+	.get_mode	= stmp3xxx_get_mode,
+	.get_optimum_mode = stmp3xxx_get_optimum_mode,
+};
+
+static struct regulator_desc stmp3xxx_reg_desc[] = {
+	{
+		.name = "vddd",
+		.id = STMP3XXX_VDDD,
+		.ops = &stmp3xxx_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vdda",
+		.id = STMP3XXX_VDDA,
+		.ops = &stmp3xxx_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vddio",
+		.id = STMP3XXX_VDDIO,
+		.ops = &stmp3xxx_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "vddd_bo",
+		.id = STMP3XXX_VDDDBO,
+		.ops = &stmp3xxx_rops,
+		.irq = 0,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE
+	},
+	{
+		.name = "overall_current",
+		.id = STMP3XXX_OVERALL_CUR,
+		.ops = &stmp3xxx_rops,
+		.irq = 0,
+		.type = REGULATOR_CURRENT,
+		.owner = THIS_MODULE
+	},
+};
+
+static int reg_callback(struct notifier_block *self,
+			unsigned long event, void *data)
+{
+	unsigned long flags;
+	struct stmp3xxx_regulator *sreg =
+		container_of(self, struct stmp3xxx_regulator , nb);
+
+	switch (event) {
+	case STMP3XXX_REG5V_IS_USB:
+		spin_lock_irqsave(&sreg->lock, flags);
+		sreg->rdata->max_current = 500000;
+		spin_unlock_irqrestore(&sreg->lock, flags);
+		break;
+	case STMP3XXX_REG5V_NOT_USB:
+		spin_lock_irqsave(&sreg->lock, flags);
+		sreg->rdata->max_current = 0x7fffffff;
+		spin_unlock_irqrestore(&sreg->lock, flags);
+		break;
+	}
+
+	return 0;
+}
+
+int stmp3xxx_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_desc *rdesc;
+	struct regulator_dev *rdev;
+	struct stmp3xxx_regulator *sreg;
+
+	sreg = platform_get_drvdata(pdev);
+	sreg->cur_current = 0;
+	sreg->next_current = 0;
+	sreg->cur_voltage = 0;
+
+	init_waitqueue_head(&sreg->wait_q);
+	spin_lock_init(&sreg->lock);
+
+	if (pdev->id > STMP3XXX_OVERALL_CUR) {
+		rdesc = kzalloc(sizeof(struct regulator_desc), GFP_KERNEL);
+		memcpy(rdesc, &stmp3xxx_reg_desc[STMP3XXX_OVERALL_CUR],
+			sizeof(struct regulator_desc));
+		rdesc->name = kstrdup(sreg->rdata->name, GFP_KERNEL);
+	} else
+		rdesc = &stmp3xxx_reg_desc[pdev->id];
+
+	pr_debug("probing regulator %s %s %d\n",
+			sreg->rdata->name,
+			rdesc->name,
+			pdev->id);
+
+	/* register regulator */
+	rdev = regulator_register(rdesc, &pdev->dev,
+				  sreg);
+
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s\n",
+			rdesc->name);
+		return PTR_ERR(rdev);
+	}
+
+	if (sreg->rdata->max_current) {
+		struct regulator *regu;
+		regu = regulator_get(NULL, sreg->rdata->name);
+		sreg->nb.notifier_call = reg_callback;
+		regulator_register_notifier(regu, &sreg->nb);
+	}
+
+	return 0;
+}
+
+
+int stmp3xxx_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+
+	return 0;
+
+}
+
+int stmp3xxx_register_regulator(
+		struct stmp3xxx_regulator *reg_data, int reg,
+			      struct regulator_init_data *initdata)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	pdev = platform_device_alloc("stmp3xxx_reg", reg);
+	if (!pdev)
+		return -ENOMEM;
+
+	pdev->dev.platform_data = initdata;
+
+	platform_set_drvdata(pdev, reg_data);
+	ret = platform_device_add(pdev);
+
+	if (ret != 0) {
+		pr_debug("Failed to register regulator %d: %d\n",
+			reg, ret);
+		platform_device_del(pdev);
+	}
+	pr_debug("register regulator %s, %d: %d\n",
+			reg_data->rdata->name, reg, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stmp3xxx_register_regulator);
+
+struct platform_driver stmp3xxx_reg = {
+	.driver = {
+		.name	= "stmp3xxx_reg",
+	},
+	.probe	= stmp3xxx_regulator_probe,
+	.remove	= stmp3xxx_regulator_remove,
+};
+
+int stmp3xxx_regulator_init(void)
+{
+	return platform_driver_register(&stmp3xxx_reg);
+}
+
+void stmp3xxx_regulator_exit(void)
+{
+	platform_driver_unregister(&stmp3xxx_reg);
+}
+
+postcore_initcall(stmp3xxx_regulator_init);
+module_exit(stmp3xxx_regulator_exit);
+
-- 
1.5.4.4

