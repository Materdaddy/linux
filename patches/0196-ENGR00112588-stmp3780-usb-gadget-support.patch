From bacdad2186fb828c5ea1250839c08efafb9a7f7f Mon Sep 17 00:00:00 2001
From: Jun Li <r65092@freescale.com>
Date: Mon, 18 May 2009 10:49:25 +0800
Subject: [PATCH] ENGR00112588 stmp3780 usb gadget support.

port stmp378x usb gadget driver to linux 2.6.28.
use one gadget driver for all i.MX and STMP3XXX chips usb.

Signed-off-by: Li Jun <r65092@freescale.com>
---
 arch/arm/mach-stmp3xxx/devices.c                   |   34 +++++++
 arch/arm/mach-stmp3xxx/include/mach/arc_otg.h      |   97 ++++++++++++++++++++
 .../mach-stmp3xxx/include/mach/fsl_usb_gadget.h    |   40 ++++++++
 arch/arm/mach-stmp3xxx/include/mach/stmp3xxx.h     |    2 +-
 arch/arm/mach-stmp3xxx/stmp378x_devb.c             |   17 +--
 drivers/usb/gadget/Kconfig                         |    4 +-
 drivers/usb/gadget/arcotg_udc.c                    |   21 +++-
 drivers/usb/gadget/arcotg_udc.h                    |    7 +-
 include/linux/fsl_devices.h                        |    3 +-
 9 files changed, 203 insertions(+), 22 deletions(-)

diff --git a/arch/arm/mach-stmp3xxx/devices.c b/arch/arm/mach-stmp3xxx/devices.c
index fc4d376..0ff1719 100644
--- a/arch/arm/mach-stmp3xxx/devices.c
+++ b/arch/arm/mach-stmp3xxx/devices.c
@@ -250,6 +250,40 @@ struct platform_device stmp3xxx_mmc = {
 	.num_resources = ARRAY_SIZE(mmc1_resource),
 };
 
+static struct resource usb_resources[] = {
+	[0] = {
+		.start	= REGS_USBCTRL_BASE,
+		.end	= REGS_USBCTRL_BASE + SZ_4K,
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= IRQ_USB_CTRL,
+		.end	= IRQ_USB_CTRL,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct fsl_usb2_platform_data udc_platform_data = {
+	.operating_mode = FSL_USB2_DR_DEVICE,
+	.phy_mode	= FSL_USB2_PHY_UTMI,
+	.port_enables	= FSL_USB2_DONT_REMAP,
+	.platform_init	= NULL,
+	.platform_uninit = NULL,
+};
+
+struct platform_device stmp3xxx_udc = {
+	.name		= "fsl-usb2-udc",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &common_dmamask,
+		.coherent_dma_mask	= COMMON_COHERENT_DMAMASK,
+		.platform_data		= &udc_platform_data,
+	},
+	.num_resources	= ARRAY_SIZE(usb_resources),
+	.resource	= usb_resources,
+};
+
 struct platform_device stmp3xxx_rtc = {
 	.name		= "stmp3xxx-rtc",
 	.id		= -1,
diff --git a/arch/arm/mach-stmp3xxx/include/mach/arc_otg.h b/arch/arm/mach-stmp3xxx/include/mach/arc_otg.h
new file mode 100644
index 0000000..e0213b2
--- /dev/null
+++ b/arch/arm/mach-stmp3xxx/include/mach/arc_otg.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+#include <mach/hardware.h>
+
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30)/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI			(0 << 30)/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30)/* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30)/* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30)/* serial */
+#define PORTSC_STS			(1 << 29)/* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28)/* UTMI width */
+#define PORTSC_PORT_POWER		(1 << 12)/* port power */
+#define PORTSC_LS_MASK			(3 << 10)/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)/* current connect status */
+
+#define PORTSC_W1C_BITS (PORTSC_CONNECT_STATUS_CHANGE |	\
+	PORTSC_PORT_EN_DIS_CHANGE |	\
+	PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	(~(0xff << 16))/* Interrupt Threshold Control */
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+#endif
diff --git a/arch/arm/mach-stmp3xxx/include/mach/fsl_usb_gadget.h b/arch/arm/mach-stmp3xxx/include/mach/fsl_usb_gadget.h
new file mode 100644
index 0000000..638bfa4
--- /dev/null
+++ b/arch/arm/mach-stmp3xxx/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+}
+
+static inline void
+fsl_platform_set_test_mode(struct fsl_usb2_platform_data *pdata,
+		enum usb_test_mode mode)
+{
+}
diff --git a/arch/arm/mach-stmp3xxx/include/mach/stmp3xxx.h b/arch/arm/mach-stmp3xxx/include/mach/stmp3xxx.h
index a505687..4d497b6 100644
--- a/arch/arm/mach-stmp3xxx/include/mach/stmp3xxx.h
+++ b/arch/arm/mach-stmp3xxx/include/mach/stmp3xxx.h
@@ -57,7 +57,7 @@ struct stmp3xxx_platform_persistent_data {
 #define STMP3XXX_USB_DONT_REMAP 	0x00000001
 struct stmp3xxx_usb_platform_data {
 	unsigned flags;
-	void (*phy_enable)(void);
+	int (*phy_enable)(struct platform_device *);
 	void (*hw_init)(void);
 	void (*hw_release)(void);
 };
diff --git a/arch/arm/mach-stmp3xxx/stmp378x_devb.c b/arch/arm/mach-stmp3xxx/stmp378x_devb.c
index 99f2530..3ceb329 100644
--- a/arch/arm/mach-stmp3xxx/stmp378x_devb.c
+++ b/arch/arm/mach-stmp3xxx/stmp378x_devb.c
@@ -89,6 +89,7 @@ static struct platform_device *devices[] = {
 	&stmp3xxx_appuart,
 	&stmp3xxx_dbguart,
 	&stmp3xxx_watchdog,
+	&stmp3xxx_udc,
 	&stmp3xxx_rtc,
 	&stmp3xxx_framebuffer,
 	&stmp3xxx_backlight,
@@ -189,7 +190,7 @@ static struct gpmi_platform_data gpmi_partitions = {
 	},
 };
 
-static void usb_phy_enable(void)
+static int usb_phy_enable(struct platform_device *pdev)
 {
 	/*
 	 * Set these bits so that we can force the OTG bits high
@@ -226,16 +227,7 @@ static void usb_phy_enable(void)
 	/* enable disconnect detector */
 	HW_USBPHY_CTRL_SET(BM_USBPHY_CTRL_ENHOSTDISCONDETECT);
 #endif
-}
-
-static void usb_hwinit(void)
-{
-	stmp3xxx_request_pin_group(&usb_mux_pins, "usb");
-}
-
-static void usb_hwrelease(void)
-{
-	stmp3xxx_release_pin_group(&usb_mux_pins, "usb");
+	return 0;
 }
 
 static struct stmp37xx_spi_platform_data enc_data = {
@@ -368,6 +360,7 @@ static struct i2c_board_info __initdata stmp3xxx_i2c_devices[] = {
 
 static void __init stmp378x_devb_init(void)
 {
+	struct fsl_usb2_platform_data *udata;
 	int i;
 
 	stmp3xxx_init();
@@ -377,6 +370,8 @@ static void __init stmp378x_devb_init(void)
 	stmp3xxx_set_mmc_data(&stmp3xxx_mmc.dev);
 	stmp3xxx_gpmi.dev.platform_data = &gpmi_partitions;
 	stmp3xxx_keyboard.dev.platform_data = &keyboard_data;
+	udata = stmp3xxx_udc.dev.platform_data;
+	udata->platform_init = usb_phy_enable;
 	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
 	stmp3xxx_ssp1_device_register();	/* MMC or SSP */
 	stmp3xxx_ssp2_device_register();	/* MMC or SSP */
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 21e5c6d..b4bc9b2 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -410,7 +410,7 @@ config USB_GOKU
 
 config USB_GADGET_ARC
 	boolean "Freescale USB Device Controller"
-	depends on ARCH_MXC
+	depends on ARCH_MXC || ARCH_STMP3XXX
 	select USB_GADGET_DUALSPEED if USB_GADGET_FSL_1504 || USB_GADGET_FSL_UTMI
 	help
 	   Some Freescale processors have a USBOTG controller,
@@ -489,7 +489,7 @@ config USB_GADGET_ARC_OTG
 
 config USB_GADGET_WAKE_UP
 	bool "Support gadget wake up by DR port"
-	depends on USB_GADGET_ARC_OTG
+	depends on USB_GADGET_ARC_OTG && ARCH_MXC
 	default n
 	help
 	  Enable system wake up from SR or DSM mode by connected host.
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index a376acd..0c393aa 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -2643,10 +2643,17 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		goto err1a;
 	}
 #endif
-	dr_regs = ioremap(res->start, res->end - res->start + 1);
-	if (!dr_regs) {
-		ret = -ENOMEM;
-		goto err1;
+
+	if ((pdata->port_enables & FSL_USB2_DONT_REMAP) == 0) {
+		dr_regs = ioremap(res->start, res->end - res->start + 1);
+		if (!dr_regs) {
+			ret = -ENOMEM;
+			goto err1;
+		}
+		udc_controller->dr_remapped = !0;
+	} else {
+		dr_regs = (void *)res->start;
+		dev_warn(&pdev->dev, "does not remap its address space\n");
 	}
 	pdata->regs = (void *)dr_regs;
 	/*
@@ -2775,7 +2782,8 @@ err2:
 	if (pdata->platform_uninit)
 		pdata->platform_uninit(pdata);
 err2a:
-	iounmap(dr_regs);
+	if (udc_controller->dr_remapped)
+		iounmap(dr_regs);
 err1:
 	if (!udc_controller->transceiver)
 		release_mem_region(res->start, res->end - res->start + 1);
@@ -2813,7 +2821,8 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 #endif
 	dma_pool_destroy(udc_controller->td_pool);
 	free_irq(udc_controller->irq, udc_controller);
-	iounmap(dr_regs);
+	if (udc_controller->dr_remapped)
+		iounmap(dr_regs);
 
 #ifndef CONFIG_USB_OTG
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index b1f6a70..ffdcb2a 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -24,8 +24,12 @@
 #define FALSE 0
 
 #define MSC_BULK_CB_WRAP_LEN 31
+#if CONFIG_ARCH_MXC
 #define USE_MSC_WR(len) (((cpu_is_mx37_rev(CHIP_REV_1_0) == 1) ||\
 	(cpu_is_mx51_rev(CHIP_REV_2_0) < 0)) && ((len) == MSC_BULK_CB_WRAP_LEN))
+#else
+#define USE_MSC_WR(len) false
+#endif
 
 /* Iram patch */
 #ifdef CONFIG_USB_STATIC_IRAM_PPH
@@ -567,6 +571,7 @@ struct fsl_udc {
 	unsigned stopped:1;
 	unsigned remote_wakeup:1;
 	unsigned already_stopped:1;
+	unsigned dr_remapped:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	struct fsl_req *status_req;	/* ep0 status request */
@@ -670,7 +675,7 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 /* Bulk only class request */
 #define USB_BULK_RESET_REQUEST          0xff
 
-#ifdef CONFIG_ARCH_MXC
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_ARCH_STMP3XXX)
 #include <mach/fsl_usb_gadget.h>
 #elif CONFIG_PPC32
 #include <asm/fsl_usb_gadget.h>
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 5fc2407..6c417ca 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -6,7 +6,7 @@
  *
  * Maintainer: Kumar Gala <galak@kernel.crashing.org>
  *
- * Copyright 2004 Freescale Semiconductor, Inc
+ * Copyright 2009 Freescale Semiconductor, Inc
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -144,6 +144,7 @@ struct fsl_usb2_platform_data {
 /* Flags in fsl_usb2_mph_platform_data */
 #define FSL_USB2_PORT0_ENABLED	0x00000001
 #define FSL_USB2_PORT1_ENABLED	0x00000002
+#define FSL_USB2_DONT_REMAP	0x10000000
 
 struct fsl_spi_platform_data {
 	u32 	initial_spmode;	/* initial SPMODE value */
-- 
1.5.4.4

