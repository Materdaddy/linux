From 2a06efa81125dfa2d6602e280abc5de60007d8ae Mon Sep 17 00:00:00 2001
From: Ann Thornton <Ann.Thornton@freescale.com>
Date: Wed, 8 Apr 2009 12:15:49 -0500
Subject: [PATCH] ENGR00110536-1 Made files less regulator specific. Added some error checking.

The structure pmic_platform_data is used to specify the init function instead of
conditional compilations. pmic_alloc_data is added instead of regulator
specific initialization. Checks are made before getting and enabling regulators.

Signed-off-by: Ann Thornton <Ann.Thornton@freescale.com>
---
 drivers/media/video/mxc/capture/ov3640.c |   94 +++++++++++++++++-------------
 drivers/mmc/host/mxc_mmc.c               |   10 ++-
 drivers/mxc/pmic/core/pmic.h             |    4 +-
 drivers/mxc/pmic/core/pmic_core_spi.c    |   28 +++++-----
 include/linux/pmic_external.h            |   36 ++----------
 5 files changed, 82 insertions(+), 90 deletions(-)

diff --git a/drivers/media/video/mxc/capture/ov3640.c b/drivers/media/video/mxc/capture/ov3640.c
index 7c2d3e3..37d65bb 100644
--- a/drivers/media/video/mxc/capture/ov3640.c
+++ b/drivers/media/video/mxc/capture/ov3640.c
@@ -953,55 +953,69 @@ static int ov3640_probe(struct i2c_client *client,
 	ov3640_data.streamcap.timeperframe.denominator = DEFAULT_FPS;
 	ov3640_data.streamcap.timeperframe.numerator = 1;
 
-	io_regulator = regulator_get(&client->dev, plat_data->io_regulator);
-	if (!IS_ERR_VALUE((u32)io_regulator)) {
-		regulator_set_voltage(io_regulator, OV3640_VOLTAGE_DIGITAL_IO,
-				      OV3640_VOLTAGE_DIGITAL_IO);
-		if (regulator_enable(io_regulator) != 0) {
-			pr_err("%s:io set voltage error\n", __func__);
-			goto err1;
-		} else {
-			dev_dbg(&client->dev,
-				"%s:io set voltage ok\n", __func__);
+	if (plat_data->io_regulator) {
+		io_regulator = regulator_get(&client->dev,
+					     plat_data->io_regulator);
+		if (!IS_ERR_VALUE((u32)io_regulator)) {
+			regulator_set_voltage(io_regulator,
+					      OV3640_VOLTAGE_DIGITAL_IO,
+					      OV3640_VOLTAGE_DIGITAL_IO);
+			if (regulator_enable(io_regulator) != 0) {
+				pr_err("%s:io set voltage error\n", __func__);
+				goto err1;
+			} else {
+				dev_dbg(&client->dev,
+					"%s:io set voltage ok\n", __func__);
+			}
 		}
 	}
 
-	core_regulator = regulator_get(&client->dev, plat_data->core_regulator);
-	if (!IS_ERR_VALUE((u32)core_regulator)) {
-		regulator_set_voltage(core_regulator,
-				      OV3640_VOLTAGE_DIGITAL_CORE,
-				      OV3640_VOLTAGE_DIGITAL_CORE);
-		if (regulator_enable(core_regulator) != 0) {
-			pr_err("%s:core set voltage error\n", __func__);
-			goto err2;
-		} else {
-			dev_dbg(&client->dev,
-				"%s:core set voltage ok\n", __func__);
+	if (plat_data->core_regulator) {
+		core_regulator = regulator_get(&client->dev,
+					       plat_data->core_regulator);
+		if (!IS_ERR_VALUE((u32)core_regulator)) {
+			regulator_set_voltage(core_regulator,
+					      OV3640_VOLTAGE_DIGITAL_CORE,
+					      OV3640_VOLTAGE_DIGITAL_CORE);
+			if (regulator_enable(core_regulator) != 0) {
+				pr_err("%s:core set voltage error\n", __func__);
+				goto err2;
+			} else {
+				dev_dbg(&client->dev,
+					"%s:core set voltage ok\n", __func__);
+			}
 		}
 	}
 
-	analog_regulator =
-		regulator_get(&client->dev, plat_data->analog_regulator);
-	if (!IS_ERR_VALUE((u32)analog_regulator)) {
-		regulator_set_voltage(analog_regulator, OV3640_VOLTAGE_ANALOG,
-				      OV3640_VOLTAGE_ANALOG);
-		if (regulator_enable(analog_regulator) != 0) {
-			pr_err("%s:analog set voltage error\n", __func__);
-			goto err3;
-		} else {
-			dev_dbg(&client->dev,
-				"%s:analog set voltage ok\n", __func__);
+	if (plat_data->analog_regulator) {
+		analog_regulator = regulator_get(&client->dev,
+						 plat_data->analog_regulator);
+		if (!IS_ERR_VALUE((u32)analog_regulator)) {
+			regulator_set_voltage(analog_regulator,
+					      OV3640_VOLTAGE_ANALOG,
+					      OV3640_VOLTAGE_ANALOG);
+			if (regulator_enable(analog_regulator) != 0) {
+				pr_err("%s:analog set voltage error\n",
+					__func__);
+				goto err3;
+			} else {
+				dev_dbg(&client->dev,
+					"%s:analog set voltage ok\n", __func__);
+			}
 		}
 	}
 
-	gpo_regulator = regulator_get(&client->dev, plat_data->gpo_regulator);
-	if (!IS_ERR_VALUE((u32)gpo_regulator)) {
-		if (regulator_enable(gpo_regulator) != 0) {
-			pr_err("%s:gpo3 enable error\n", __func__);
-			goto err4;
-		} else {
-			dev_dbg(&client->dev,
-				"%s:gpo3 enable ok\n", __func__);
+	if (plat_data->gpo_regulator) {
+		gpo_regulator = regulator_get(&client->dev,
+					      plat_data->gpo_regulator);
+		if (!IS_ERR_VALUE((u32)gpo_regulator)) {
+			if (regulator_enable(gpo_regulator) != 0) {
+				pr_err("%s:gpo3 enable error\n", __func__);
+				goto err4;
+			} else {
+				dev_dbg(&client->dev,
+					"%s:gpo3 enable ok\n", __func__);
+			}
 		}
 	}
 
diff --git a/drivers/mmc/host/mxc_mmc.c b/drivers/mmc/host/mxc_mmc.c
index ccf766c..4b54b57 100644
--- a/drivers/mmc/host/mxc_mmc.c
+++ b/drivers/mmc/host/mxc_mmc.c
@@ -1261,9 +1261,11 @@ static int mxcmci_probe(struct platform_device *pdev)
 			ret = PTR_ERR(host->regulator_mmc);
 			goto out1;
 		}
-		if (regulator_enable(host->regulator_mmc) == 0) {
-			pr_debug("mmc power on\n");
-			msleep(1);
+		if (!regulator_is_enabled(host->regulator_mmc)) {
+			if (regulator_enable(host->regulator_mmc) == 0) {
+				pr_debug("mmc power on\n");
+				msleep(1);
+			}
 		}
 	}
 
@@ -1467,7 +1469,7 @@ static int mxcmci_resume(struct platform_device *pdev)
 	}
 
 	/* enable pwr supply for SDHC */
-	if (host->regulator_mmc) {
+	if (host->regulator_mmc && !regulator_is_enabled(host->regulator_mmc)) {
 		regulator_enable(host->regulator_mmc);
 		msleep(1);
 	}
diff --git a/drivers/mxc/pmic/core/pmic.h b/drivers/mxc/pmic/core/pmic.h
index 2456600..b1382a3 100644
--- a/drivers/mxc/pmic/core/pmic.h
+++ b/drivers/mxc/pmic/core/pmic.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -129,4 +129,6 @@ static inline PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi)
 }
 #endif
 
+void *pmic_alloc_data(struct device *dev);
+
 #endif				/* __PMIC_H__ */
diff --git a/drivers/mxc/pmic/core/pmic_core_spi.c b/drivers/mxc/pmic/core/pmic_core_spi.c
index dd986c0..8acee02 100644
--- a/drivers/mxc/pmic/core/pmic_core_spi.c
+++ b/drivers/mxc/pmic/core/pmic_core_spi.c
@@ -31,7 +31,6 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/spi/spi.h>
-#include <linux/mfd/mc13892/core.h>
 #include <linux/pmic_external.h>
 #include <linux/pmic_status.h>
 
@@ -157,8 +156,7 @@ static struct spi_driver pmic_driver;
 static int __devinit pmic_probe(struct spi_device *spi)
 {
 	int ret = 0;
-	struct mc13892 *mc13892;
-	struct mc13892_platform_data *plat_data = spi->dev.platform_data;
+	struct pmic_platform_data *plat_data = spi->dev.platform_data;
 
 	if (!strcmp(spi->dev.bus_id, PMIC_ARBITRATION)) {
 		if (PMIC_SUCCESS != pmic_fix_arbitration(spi)) {
@@ -193,23 +191,21 @@ static int __devinit pmic_probe(struct spi_device *spi)
 			mxc_pmic_version.revision);
 	}
 
-	mc13892 = kzalloc(sizeof(struct mc13892), GFP_KERNEL);
-	if (mc13892 == NULL)
-		return -ENOMEM;
-
-	spi_set_drvdata(spi, mc13892);
-	mc13892->dev = &spi->dev;
-	mc13892->spi_device = spi;
+	spi_set_drvdata(spi, pmic_alloc_data(&(spi->dev)));
 
 	/* Initialize the PMIC parameters */
 	ret = pmic_init_registers();
 	if (ret != PMIC_SUCCESS) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
 		return PMIC_ERROR;
 	}
 
 	pmic_event_wq = create_workqueue("pmic_spi");
 	if (!pmic_event_wq) {
-		pr_err("mc13892 pmic driver init: fail to create work queue");
+		pr_err("pmic driver init: fail to create work queue");
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
 		return -EFAULT;
 	}
 
@@ -217,14 +213,19 @@ static int __devinit pmic_probe(struct spi_device *spi)
 	set_irq_type(spi->irq, IRQF_TRIGGER_RISING);
 	ret = request_irq(spi->irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
 	if (ret) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
 		dev_err((struct device *)spi, "gpio1: irq%d error.", spi->irq);
 		return ret;
 	}
 
 	if (plat_data && plat_data->init) {
-		ret = plat_data->init(mc13892);
-		if (ret != 0)
+		ret = plat_data->init(spi_get_drvdata(spi));
+		if (ret != 0) {
+			kfree(spi_get_drvdata(spi));
+			spi_set_drvdata(spi, NULL);
 			return PMIC_ERROR;
+		}
 	}
 
 	power_ldm.dev.platform_data = spi->dev.platform_data;
@@ -285,7 +286,6 @@ static struct spi_driver pmic_driver = {
  */
 static int __init pmic_init(void)
 {
-	pr_debug("Registering the PMIC Protocol Driver\n");
 	return spi_register_driver(&pmic_driver);
 }
 
diff --git a/include/linux/pmic_external.h b/include/linux/pmic_external.h
index 8b2c7af..96d61b7 100644
--- a/include/linux/pmic_external.h
+++ b/include/linux/pmic_external.h
@@ -1096,39 +1096,13 @@ PMIC_STATUS pmic_get_sensors(t_sensor_bits * sensor_bits);
 void pmic_event_callback(type_event event);
 void pmic_event_list_init(void);
 
-#ifdef CONFIG_REGULATOR_MC13783
-/*!
- * This function is used to initialize the regulator for MC13783.
- *
- * @return      Returns 0.
- */
-int reg_mc13783_probe(struct device *dev);
-#else
-static inline int reg_mc13783_probe(struct device *dev)
-{
-	return 0;
-};
-#endif
-
-#ifdef CONFIG_REGULATOR_MC13892
-int mc13892_regulator_i2c_init(struct i2c_client *client);
-#else
-static inline int mc13892_regulator_i2c_init(struct i2c_client *client)
-{
-	return 0;
-};
-#endif
-
-#ifdef CONFIG_REGULATOR_MC34704
-int reg_mc34704_probe(void);
-#else
-static inline int reg_mc34704_probe(void)
-{
-	return 0;
-};
-#endif
 #endif				/*CONFIG_MXC_PMIC*/
 #endif				/* __KERNEL__ */
 /* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
 
+struct pmic_platform_data {
+	int (*init)(void *);
+	int power_key_irq;
+};
+
 #endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
-- 
1.5.4.4

