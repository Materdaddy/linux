From 8d7a6de5321dbea105b06b6a08df0b10c5785a66 Mon Sep 17 00:00:00 2001
From: Albert Chen <R65187@freescale.com>
Date: Wed, 3 Jun 2009 11:34:50 +0800
Subject: [PATCH] ENGR00112509 : [MX37] failed to test our MSC driver with USBCV 1.3.

      1. pass msc class driver test with usbcv.
      2. set_bulk_out_req_length should set 512, not 31.
      3. fixed the missing ACK issue.
      4. remove the compile warning.

Signed-off-by: Albert Chen <r65187@freescale.com>
---
 arch/arm/configs/imx37_3stack_defconfig |    2 +-
 drivers/usb/gadget/arcotg_udc.c         |  111 ++++++++++--------------------
 drivers/usb/gadget/arcotg_udc.h         |    3 +-
 drivers/usb/gadget/file_storage.c       |    2 +
 4 files changed, 41 insertions(+), 77 deletions(-)

diff --git a/arch/arm/configs/imx37_3stack_defconfig b/arch/arm/configs/imx37_3stack_defconfig
index b0ea799..2d01ad6 100644
--- a/arch/arm/configs/imx37_3stack_defconfig
+++ b/arch/arm/configs/imx37_3stack_defconfig
@@ -1343,7 +1343,7 @@ CONFIG_USB_GADGET_SELECTED=y
 # CONFIG_USB_GADGET_NET2280 is not set
 # CONFIG_USB_GADGET_GOKU is not set
 CONFIG_USB_GADGET_ARC=y
-CONFIG_USB_STATIC_IRAM_PPH=y
+# CONFIG_USB_STATIC_IRAM_PPH is not set
 CONFIG_USB_ARC=m
 # CONFIG_USB_GADGET_DUMMY_HCD is not set
 CONFIG_USB_GADGET_DUALSPEED=y
diff --git a/drivers/usb/gadget/arcotg_udc.c b/drivers/usb/gadget/arcotg_udc.c
index 192eddb..2d3f89b 100644
--- a/drivers/usb/gadget/arcotg_udc.c
+++ b/drivers/usb/gadget/arcotg_udc.c
@@ -89,6 +89,8 @@ fsl_ep0_desc = {
 };
 static const size_t g_iram_size = IRAM_TD_PPH_SIZE;
 
+typedef int (*dev_sus)(struct device *dev, pm_message_t state);
+typedef int (*dev_res) (struct device *dev);
 static int udc_suspend(struct fsl_udc *udc);
 static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
 static int fsl_udc_resume(struct platform_device *pdev);
@@ -924,8 +926,8 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	int is_iso = 0;
 
 	/* catch various bogus parameters */
-	if (!_req || !req->req.complete || !req->req.buf
-			|| !list_empty(&req->queue)) {
+	if (!_req || !req->req.buf || (ep_index(ep)
+				      && !list_empty(&req->queue))) {
 		VDBG("%s, bad params\n", __func__);
 		return -EINVAL;
 	}
@@ -980,10 +982,6 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 		return -ENOMEM;
 	}
 
-	/* Update ep0 state */
-	if ((ep_index(ep) == 0))
-		udc->ep0_state = DATA_STATE_XMIT;
-
 	/* irq handler advances the queue */
 	if (req != NULL)
 		list_add_tail(&req->queue, &ep->queue);
@@ -1113,7 +1111,6 @@ static int fsl_ep_set_halt(struct usb_ep *_ep, int value)
 	spin_unlock_irqrestore(&ep->udc->lock, flags);
 
 	if (ep_index(ep) == 0) {
-		udc->ep0_state = WAIT_FOR_SETUP;
 		udc->ep0_dir = 0;
 	}
 out:
@@ -1325,7 +1322,6 @@ static void ep0stall(struct fsl_udc *udc)
 	tmp = fsl_readl(&dr_regs->endptctrl[0]);
 	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
 	fsl_writel(tmp, &dr_regs->endptctrl[0]);
-	udc->ep0_state = WAIT_FOR_SETUP;
 	udc->ep0_dir = 0;
 }
 
@@ -1342,24 +1338,12 @@ static int ep0_prime_status(struct fsl_udc *udc, int direction)
 		udc->ep0_dir = USB_DIR_OUT;
 
 	ep = &udc->eps[0];
-	udc->ep0_state = WAIT_FOR_OUT_STATUS;
 
 	req->ep = ep;
 	req->req.length = 0;
 	req->req.status = -EINPROGRESS;
-	req->req.actual = 0;
-	req->req.complete = NULL;
-	req->dtd_count = 0;
-
-	if (fsl_req_to_dtd(req) == 0)
-		status = fsl_queue_td(ep, req);
-	else
-		return -ENOMEM;
-
-	if (status)
-		ERR("Can't queue ep0 status request \n");
-	list_add_tail(&req->queue, &ep->queue);
 
+	status = fsl_ep_queue(&ep->ep, &req->req, GFP_ATOMIC);
 	return status;
 }
 
@@ -1425,32 +1409,24 @@ static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,
 	}
 
 	udc->ep0_dir = USB_DIR_IN;
-	/* Borrow the per device status_req */
-	req = udc->status_req;
+	/* Borrow the per device data_req */
+	/* status_req had been used to prime status */
+	req = udc->data_req;
 	/* Fill in the reqest structure */
 	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
 	req->ep = ep;
 	req->req.length = 2;
-	req->req.status = -EINPROGRESS;
-	req->req.actual = 0;
-	req->req.complete = NULL;
-	req->dtd_count = 0;
-
-	/* prime the data phase */
-	if ((fsl_req_to_dtd(req) == 0))
-		status = fsl_queue_td(ep, req);
-	else			/* no mem */
-		goto stall;
 
+	status = fsl_ep_queue(&ep->ep, &req->req, GFP_ATOMIC);
 	if (status) {
+		udc_reset_ep_queue(udc, 0);
 		ERR("Can't respond to getstatus request \n");
 		goto stall;
 	}
-	list_add_tail(&req->queue, &ep->queue);
-	udc->ep0_state = DATA_STATE_XMIT;
 	return;
 stall:
 	ep0stall(udc);
+
 }
 
 static void setup_received_irq(struct fsl_udc *udc,
@@ -1462,6 +1438,15 @@ static void setup_received_irq(struct fsl_udc *udc,
 
 	udc_reset_ep_queue(udc, 0);
 
+	if (wLength) {
+		int dir;
+		dir = EP_DIR_IN;
+		if (setup->bRequestType & USB_DIR_IN) {
+			dir = EP_DIR_OUT;
+		}
+		if (ep0_prime_status(udc, dir))
+			ep0stall(udc);
+	}
 	/* We process some stardard setup requests here */
 	switch (setup->bRequest) {
 	case USB_REQ_GET_STATUS:
@@ -1552,11 +1537,11 @@ static void setup_received_irq(struct fsl_udc *udc,
 				?  USB_DIR_IN : USB_DIR_OUT;
 		spin_unlock(&udc->lock);
 		if (udc->driver->setup(&udc->gadget,
-				&udc->local_setup_buff) < 0)
+				&udc->local_setup_buff) < 0) {
+			/* cancel status phase */
+			udc_reset_ep_queue(udc, 0);
 			ep0stall(udc);
-		spin_lock(&udc->lock);
-		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
-				?  DATA_STATE_XMIT : DATA_STATE_RECV;
+		}
 	} else {
 		/* No data phase, IN status from gadget */
 		udc->ep0_dir = USB_DIR_IN;
@@ -1564,9 +1549,8 @@ static void setup_received_irq(struct fsl_udc *udc,
 		if (udc->driver->setup(&udc->gadget,
 				&udc->local_setup_buff) < 0)
 			ep0stall(udc);
-		spin_lock(&udc->lock);
-		udc->ep0_state = WAIT_FOR_OUT_STATUS;
 	}
+	spin_lock(&udc->lock);
 }
 
 /* Process request for Data or Status phase of ep0
@@ -1582,28 +1566,6 @@ static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
 	}
 
 	done(ep0, req, 0);
-
-	switch (udc->ep0_state) {
-	case DATA_STATE_XMIT:
-		/* receive status phase */
-		if (ep0_prime_status(udc, EP_DIR_OUT))
-			ep0stall(udc);
-		break;
-	case DATA_STATE_RECV:
-		/* send status phase */
-		if (ep0_prime_status(udc, EP_DIR_IN))
-			ep0stall(udc);
-		break;
-	case WAIT_FOR_OUT_STATUS:
-		udc->ep0_state = WAIT_FOR_SETUP;
-		break;
-	case WAIT_FOR_SETUP:
-		ERR("Unexpect ep0 packets \n");
-		break;
-	default:
-		ep0stall(udc);
-		break;
-	}
 }
 
 /* Tripwire mechanism to ensure a setup packet payload is extracted without
@@ -1822,7 +1784,7 @@ static void dtd_complete_irq(struct fsl_udc *udc)
 
 		/* If the ep is configured */
 		if (curr_ep->name == NULL) {
-			WARN("Invalid EP?");
+			INFO("Invalid EP?");
 			continue;
 		}
 
@@ -1892,8 +1854,6 @@ static void port_change_irq(struct fsl_udc *udc)
 /* Process suspend interrupt */
 static void suspend_irq(struct fsl_udc *udc)
 {
-	u32 port_status;
-
 	pr_debug("%s\n", __func__);
 
 	udc->resume_state = udc->usb_state;
@@ -1957,7 +1917,6 @@ static void reset_irq(struct fsl_udc *udc)
 	/* Clear usb state */
 	udc->resume_state = 0;
 	udc->ep0_dir = 0;
-	udc->ep0_state = WAIT_FOR_SETUP;
 	udc->remote_wakeup = 0;	/* default to 0 on reset */
 	udc->gadget.b_hnp_enable = 0;
 	udc->gadget.a_hnp_support = 0;
@@ -2138,8 +2097,8 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
 
 		/* export udc suspend/resume call to OTG */
-		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
-		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
+		udc_controller->gadget.dev.driver->suspend = (dev_sus)fsl_udc_suspend;
+		udc_controller->gadget.dev.driver->resume = (dev_res)fsl_udc_resume;
 
 		/* connect to bus through transceiver */
 		if (udc_controller->transceiver) {
@@ -2157,7 +2116,6 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
 		dr_controller_run(udc_controller);
 		udc_controller->usb_state = USB_STATE_ATTACHED;
-		udc_controller->ep0_state = WAIT_FOR_SETUP;
 		udc_controller->ep0_dir = 0;
 	}
 	printk(KERN_INFO "%s: bind to driver %s \n",
@@ -2190,7 +2148,6 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 
 	/* in fact, no needed */
 	udc_controller->usb_state = USB_STATE_ATTACHED;
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
 	udc_controller->ep0_dir = 0;
 
 	/* stand operation */
@@ -2546,6 +2503,11 @@ static int __init struct_udc_setup(struct fsl_udc *udc,
 	/* allocate a small amount of memory to get valid address */
 	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
 	udc->status_req->req.dma = virt_to_phys(udc->status_req->req.buf);
+	/* Initialize ep0 data request structure */
+	udc->data_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),
+			struct fsl_req, req);
+	udc->data_req->req.buf = kmalloc(8, GFP_KERNEL);
+	udc->data_req->req.dma = virt_to_phys(udc->data_req->req.buf);
 
 	udc->resume_state = USB_STATE_NOTATTACHED;
 	udc->usb_state = USB_STATE_POWERED;
@@ -2783,7 +2745,7 @@ err2:
 		pdata->platform_uninit(pdata);
 err2a:
 	if (udc_controller->dr_remapped)
-		iounmap(dr_regs);
+		iounmap((u8 __iomem *)dr_regs);
 err1:
 	if (!udc_controller->transceiver)
 		release_mem_region(res->start, resource_size(res));
@@ -2813,6 +2775,8 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	/* Free allocated memory */
 	kfree(udc_controller->status_req->req.buf);
 	kfree(udc_controller->status_req);
+	kfree(udc_controller->data_req->req.buf);
+	kfree(udc_controller->data_req);
 	kfree(udc_controller->eps);
 #ifdef POSTPONE_FREE_LAST_DTD
 	if (last_free_td != NULL)
@@ -2822,7 +2786,7 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	dma_pool_destroy(udc_controller->td_pool);
 	free_irq(udc_controller->irq, udc_controller);
 	if (udc_controller->dr_remapped)
-		iounmap(dr_regs);
+		iounmap((u8 __iomem *)dr_regs);
 
 #ifndef CONFIG_USB_OTG
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2958,7 +2922,6 @@ static int fsl_udc_resume(struct platform_device *pdev)
 		dr_controller_run(udc_controller);
 	}
 	udc_controller->usb_state = USB_STATE_ATTACHED;
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
 	udc_controller->ep0_dir = 0;
 
 	printk(KERN_INFO "USB Gadget resumed\n");
diff --git a/drivers/usb/gadget/arcotg_udc.h b/drivers/usb/gadget/arcotg_udc.h
index ffdcb2a..fbdb320 100644
--- a/drivers/usb/gadget/arcotg_udc.h
+++ b/drivers/usb/gadget/arcotg_udc.h
@@ -575,6 +575,7 @@ struct fsl_udc {
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	struct fsl_req *status_req;	/* ep0 status request */
+	struct fsl_req *data_req;	/* ep0 data request */
 	struct dma_pool *td_pool;	/* dma pool for DTD */
 	enum fsl_usb2_phy_modes phy_mode;
 
@@ -587,7 +588,6 @@ struct fsl_udc {
 	u32 resume_state;	/* USB state to resume */
 	u32 usb_state;		/* USB current state */
 	u32 usb_next_state;	/* USB next state */
-	u32 ep0_state;		/* Endpoint zero state */
 	u32 ep0_dir;		/* Endpoint zero direction: can be
 				   USB_DIR_IN or USB_DIR_OUT */
 	u32 usb_sof_count;	/* SOF count */
@@ -643,7 +643,6 @@ static void dump_msg(const char *label, const u8 * buf, unsigned int length)
 #endif
 
 #define ERR(stuff...)		printk(KERN_ERR "udc: " stuff)
-#define WARN(stuff...)		printk(KERN_WARNING "udc: " stuff)
 #define INFO(stuff...)		printk(KERN_INFO "udc: " stuff)
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index d77ad4a..2529b1f 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -712,8 +712,10 @@ static void set_bulk_out_req_length(struct fsg_dev *fsg,
 	if (rem > 0)
 		length += fsg->bulk_out_maxpacket - rem;
 	bh->outreq->length = length;
+#if 0
 	if (bh->bulk_out_intended_length == 31)
 		bh->outreq->length = 31;
+#endif
 }
 
 static struct fsg_dev			*the_fsg;
-- 
1.5.4.4

