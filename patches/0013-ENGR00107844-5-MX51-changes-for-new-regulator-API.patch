From b0f8eee7781a15cd2d83cca954f15db3f4eda873 Mon Sep 17 00:00:00 2001
From: Ann Thornton <Ann.Thornton@freescale.com>
Date: Tue, 3 Mar 2009 14:51:31 -0600
Subject: [PATCH] ENGR00107844-5 MX51: changes for new regulator API.

Added files and code to use the 2.6.28 version of the regulator API.

Signed-off-by: Ann Thornton <Ann.Thornton@freescale.com>
---
 arch/arm/mach-mx51/Makefile                   |    2 +-
 arch/arm/mach-mx51/board-mx51_3stack.h        |    1 +
 arch/arm/mach-mx51/mx51_3stack.c              |   87 +--------
 arch/arm/mach-mx51/mx51_3stack_pmic_mc13892.c |  259 +++++++++++++++++++++++++
 arch/arm/plat-mxc/utmixc.c                    |    5 +-
 5 files changed, 263 insertions(+), 91 deletions(-)

diff --git a/arch/arm/mach-mx51/Makefile b/arch/arm/mach-mx51/Makefile
index 31495e3..bad4e3c 100644
--- a/arch/arm/mach-mx51/Makefile
+++ b/arch/arm/mach-mx51/Makefile
@@ -9,7 +9,7 @@ obj-y   := system.o iomux.o cpu.o mm.o clock.o devices.o serial.o dma.o lpmodes.
 
 obj-$(CONFIG_CPU_V7)        += wfi.o suspend.o
 
-obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o
+obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
 
 obj-$(CONFIG_USB_EHCI_ARC_H1)   += usb_h1.o
 
diff --git a/arch/arm/mach-mx51/board-mx51_3stack.h b/arch/arm/mach-mx51/board-mx51_3stack.h
index 33aef2a..8993e90 100644
--- a/arch/arm/mach-mx51/board-mx51_3stack.h
+++ b/arch/arm/mach-mx51/board-mx51_3stack.h
@@ -124,5 +124,6 @@ extern unsigned int sdhc_get_card_det_status(struct device *dev);
 extern int sdhc_write_protect(struct device *dev);
 extern int sdhc_init_card_det(int id);
 extern int headphone_det_status(void);
+extern int __init mx51_3stack_init_mc13892(void);
 
 #endif				/* __ASM_ARCH_MXC_BOARD_MX51_3STACK_H__ */
diff --git a/arch/arm/mach-mx51/mx51_3stack.c b/arch/arm/mach-mx51/mx51_3stack.c
index fdbebf0..ced851f 100644
--- a/arch/arm/mach-mx51/mx51_3stack.c
+++ b/arch/arm/mach-mx51/mx51_3stack.c
@@ -89,86 +89,6 @@ struct cpu_wp *get_cpu_wp(int *wp)
 	return cpu_wp_auto;
 }
 
-static int __init mc13892_reg_int(void)
-{
-	int i = 0;
-	struct regulator *regulator;
-	struct regulator *gp;
-	struct regulator *lp;
-	char *reg_name[] = {
-		"SW1",
-		"SW2",
-		"SW3",
-		"SW4",
-		"SW1_STBY",
-		"SW2_STBY",
-		"SW3_STBY",
-		"SW4_STBY",
-		"SW1_DVS",
-		"SW2_DVS",
-		"SWBST",
-		"VIOHI",
-		"VPLL",
-		"VDIG",
-		"VSD",
-		"VUSB2",
-		"VVIDEO",
-		"VAUDIO",
-		"VCAM",
-		"VGEN1",
-		"VGEN2",
-		"VGEN3",
-		"USB",
-		"GPO1",
-		"GPO2",
-		"GPO3",
-		"GPO4",
-	};
-
-	for (i = 0; i < ARRAY_SIZE(reg_name); i++) {
-		regulator = regulator_get(NULL, reg_name[i]);
-		if (regulator == ERR_PTR(-ENOENT))
-			continue;
-
-		regulator_enable(regulator);
-		if ((strcmp(reg_name[i], "VIOHI") == 0) ||
-			(strcmp(reg_name[i], "VPLL") == 0) ||
-			(strcmp(reg_name[i], "VDIG") == 0) ||
-			(strcmp(reg_name[i], "VGEN2") == 0))
-			continue;
-
-		regulator_disable(regulator);
-		regulator_put(regulator);
-	}
-
-	gp = regulator_get(NULL, "SW1_STBY");
-	lp = regulator_get(NULL, "SW2_STBY");
-	regulator_enable(gp);
-	regulator_enable(lp);
-
-	if (regulator_set_voltage(gp, 700000, 700000))
-		printk(KERN_INFO "cannot set GP STBY voltage\n");
-
-	if ((mxc_cpu_is_rev(CHIP_REV_2_0)) < 0) {
-		if (regulator_set_voltage(lp, 1100000, 1100000))
-			printk(KERN_INFO "cannot set LP STBY voltage\n");
-	} else {
-		/* Cannot drop voltage for TO2.0 */
-		if (regulator_set_voltage(lp, 900000, 900000))
-			printk(KERN_INFO "cannot set LP STBY voltage\n");
-	}
-
-	regulator_disable(gp);
-	regulator_disable(lp);
-
-	regulator_put(gp);
-	regulator_put(lp);
-
-	return 0;
-}
-
-late_initcall(mc13892_reg_int);
-
 static void mxc_nop_release(struct device *dev)
 {
 	/* Nothing */
@@ -402,12 +322,6 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 #ifdef CONFIG_I2C_MXC_SELECT2
 static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	{
-	 .type = "mc13892",
-	 .addr = 0x08,
-	 .platform_data = (void *)MX51_PIN_GPIO1_5,
-	 .irq  = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
-	},
-	{
 	 .type = "wm8903-i2c",
 	 .addr = 0x1a,
 	 },
@@ -1001,6 +915,7 @@ static void __init mxc_board_init(void)
 	mxc_init_nand_mtd();
 	mxc_init_mmc();
 	mxc_init_srpgconfig();
+	mx51_3stack_init_mc13892();
 
 #if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
 
diff --git a/arch/arm/mach-mx51/mx51_3stack_pmic_mc13892.c b/arch/arm/mach-mx51/mx51_3stack_pmic_mc13892.c
new file mode 100644
index 0000000..3a6a0f3
--- /dev/null
+++ b/arch/arm/mach-mx51/mx51_3stack_pmic_mc13892.c
@@ -0,0 +1,259 @@
+/*
+ * mx51-3stack-pmic-mc13892.c  --  i.MX51 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include "iomux.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 700000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 900000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+		sw2_init.constraints.state_mem.uV = 1100000;
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq  = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx51_3stack_init_mc13892(void)
+{
+	return i2c_register_board_info(1, &mc13892_i2c_device, 1);
+}
+
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
index a258fb7..2e9c639 100644
--- a/arch/arm/plat-mxc/utmixc.c
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -59,7 +59,6 @@ static void set_power(struct fsl_xcvr_ops *this,
 		} else {
 			regulator_disable(usbotg_regux);
 		}
-		regulator_put(usbotg_regux);
 #if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
 	} else if (machine_is_mx51_3ds()) {
 		unsigned int value;
@@ -69,7 +68,6 @@ static void set_power(struct fsl_xcvr_ops *this,
 			regulator_enable(usbotg_regux);
 		else
 			regulator_disable(usbotg_regux);
-		regulator_put(usbotg_regux);
 
 		/* VUSBIN */
 		pmic_read_reg(REG_USB1, &value, 0xffffff);
@@ -80,12 +78,11 @@ static void set_power(struct fsl_xcvr_ops *this,
 		pmic_write_reg(REG_USB1, value, 0xffffff);
 
 		/* VUSBEN */
-		usbotg_regux = regulator_get(dev, "USB");
+		usbotg_regux = regulator_get(dev, "VUSB");
 		if (on)
 			regulator_enable(usbotg_regux);
 		else
 			regulator_disable(usbotg_regux);
-		regulator_put(usbotg_regux);
 #endif
 	}
 }
-- 
1.5.4.4

